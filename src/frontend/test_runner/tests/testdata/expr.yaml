# This file is automatically generated. See `src/frontend/test_runner/README.md` for more information.
- sql: |
    /* bind typed literal */
    select int '1';
  logical_plan: |
    LogicalProject { exprs: ['1':Varchar::Int32] }
      LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- sql: |
    /* bind typed literal */
    SELECT bool 't'
  logical_plan: |
    LogicalProject { exprs: ['t':Varchar::Boolean] }
      LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- sql: |
    values(must_be_unimplemented_func(1));
  binder_error: 'Feature is not yet implemented: unsupported function: "must_be_unimplemented_func", Tracking issue: https://github.com/singularity-data/piestream/issues/112'
- sql: |
    values(cast(1 as bigint));
  batch_plan: |
    BatchValues { rows: [[1:Int32::Int64]] }
- sql: |
    values(not true);
  batch_plan: |
    BatchValues { rows: [[Not(true:Boolean)]] }
- sql: |
    create table t ();
    select (((((false is not true) is true) is not false) is false) is not null) is null from t;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [IsNull(IsNotNull(IsFalse(IsNotFalse(IsTrue(IsNotTrue(false:Boolean))))))] }
        BatchScan { table: t, columns: [] }
- sql: |
    /* bind between */
    SELECT 1 between 2 and 3
  logical_plan: |
    LogicalProject { exprs: [((1:Int32 >= 2:Int32) AND (1:Int32 <= 3:Int32))] }
      LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- sql: |
    /* bind is distinct from */
    SELECT 1 IS DISTINCT FROM 2
  logical_plan: |
    LogicalProject { exprs: [IsDistinctFrom(1:Int32, 2:Int32)] }
      LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- sql: |
    /* bind is not distinct from */
    SELECT 1 IS NOT DISTINCT FROM 2
  logical_plan: |
    LogicalProject { exprs: [Not(IsDistinctFrom(1:Int32, 2:Int32))] }
      LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- sql: |
    /* in-list with aligned types */
    SELECT 1::real in (3, 1.0, 2);
  batch_plan: |
    BatchProject { exprs: [In(1:Int32::Float32, 3:Int32::Float32, 1.0:Decimal::Float32, 2:Int32::Float32)] }
      BatchValues { rows: [[]] }
- sql: |
    /* not in-list with aligned types */
    SELECT 1::real not in (3, 1.0, 2);
  batch_plan: |
    BatchProject { exprs: [Not(In(1:Int32::Float32, 3:Int32::Float32, 1.0:Decimal::Float32, 2:Int32::Float32))] }
      BatchValues { rows: [[]] }
- sql: |
    /* in-list with misaligned types */
    SELECT true in (3, 1.0, 2);
  binder_error: 'Bind error: types Boolean and Int32 cannot be matched'
- sql: |
    /* in-list with non-const: agg */
    create table t (v1 int);
    SELECT 1 in (3, 0.5*2, min(v1)) from t;
  batch_plan: |
    BatchProject { exprs: [(In(1:Int32::Decimal, 3:Int32::Decimal, (0.5:Decimal * 2:Int32)) OR (1:Int32 = $0))] }
      BatchSimpleAgg { aggs: [min($0)] }
        BatchExchange { order: [], dist: Single }
          BatchSimpleAgg { aggs: [min($0)] }
            BatchScan { table: t, columns: [v1] }
- sql: |
    /* in-list with non-const: scalar subquery */
    create table t (v1 int);
    create table b (b1 int, b2 int);
    SELECT b2 from b where 1 in (3, 1.0, (select min(v1) from t));
  batch_plan: |
    BatchProject { exprs: [$0] }
      BatchFilter { predicate: (In(1:Int32::Decimal, 3:Int32::Decimal, 1.0:Decimal) OR (1:Int32 = $1)) }
        BatchNestedLoopJoin { type: LeftOuter, predicate: true, output_indices: all }
          BatchExchange { order: [], dist: Single }
            BatchScan { table: b, columns: [b2] }
          BatchSimpleAgg { aggs: [min($0)] }
            BatchExchange { order: [], dist: Single }
              BatchSimpleAgg { aggs: [min($0)] }
                BatchScan { table: t, columns: [v1] }
- sql: |
    /* in-list with non-const: correlated ref */
    create table t (v1 int);
    create table b (b1 int, b2 int);
    SELECT b2 from b where exists (select 2 from t where v1 in (3, 1.0, b1));
  batch_plan: |
    BatchNestedLoopJoin { type: LeftSemi, predicate: (In($2::Decimal, 3:Int32::Decimal, 1.0:Decimal) OR ($3 = $0)), output_indices: [1] }
      BatchExchange { order: [], dist: Single }
        BatchScan { table: b, columns: [b1, b2] }
      BatchExchange { order: [], dist: Single }
        BatchProject { exprs: [$0, $0] }
          BatchScan { table: t, columns: [v1] }
- sql: |
    select +1.0, -2.0;
  batch_plan: |
    BatchProject { exprs: [1.0:Decimal, Neg(2.0:Decimal)] }
      BatchValues { rows: [[]] }
- sql: |
    values(round(42.4382, 2));
  batch_plan: |
    BatchValues { rows: [[RoundDigit(42.4382:Decimal, 2:Int32)]] }
- sql: |
    values(round(42.4382));
  batch_plan: |
    BatchValues { rows: [[Round(42.4382:Decimal)]] }
- sql: |
    values(round(42));
  batch_plan: |
    BatchValues { rows: [[Round(42:Int32::Float64)]] }
- sql: |
    values(round(42, 2));
  batch_plan: |
    BatchValues { rows: [[RoundDigit(42:Int32::Decimal, 2:Int32)]] }
- sql: |
    values(round(true));
  binder_error: 'Feature is not yet implemented: Round[Boolean], Tracking issue: https://github.com/singularity-data/piestream/issues/112'
- sql: |
    -- Single quoted literal can be treated as number without error.
    values(round('123'));
    -- When it is invalid, PostgreSQL reports error during explain, but we have to wait until execution as of now.
    -- values(round('abc'));
  batch_plan: |
    BatchValues { rows: [[Round('123':Varchar::Float64)]] }
- sql: |
    values(extract(hour from timestamp '2001-02-16 20:38:40'));
  batch_plan: |
    BatchValues { rows: [[Extract('HOUR':Varchar, '2001-02-16 20:38:40':Varchar::Timestamp)]] }
- sql: |
    values('Postgres' not like 'Post%');
  batch_plan: |
    BatchValues { rows: [[Not(Like('Postgres':Varchar, 'Post%':Varchar))]] }
- sql: |
    values(1 not like 1.23);
  binder_error: 'Feature is not yet implemented: Like[Int32, Decimal], Tracking issue: https://github.com/singularity-data/piestream/issues/112'
- sql: |
    select length(trim(trailing '1' from '12'))+length(trim(leading '2' from '23'))+length(trim(both '3' from '34'));
  batch_plan: |
    BatchProject { exprs: [((Length(Rtrim('12':Varchar, '1':Varchar)) + Length(Ltrim('23':Varchar, '2':Varchar))) + Length(Trim('34':Varchar, '3':Varchar)))] }
      BatchValues { rows: [[]] }
- sql: |
    select position(replace('1','1','2'),'123') where '12' like '%1';
  batch_plan: |
    BatchProject { exprs: [Position(Replace('1':Varchar, '1':Varchar, '2':Varchar), '123':Varchar)] }
      BatchFilter { predicate: Like('12':Varchar, '%1':Varchar) }
        BatchValues { rows: [[]] }
- sql: |
    /* case searched form with else */
    create table t (v1 int);
    select (case when v1=1 then 1 when v1=2 then 2 else 0.0 end) as expr from t;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [Case(($0 = 1:Int32), 1:Int32::Decimal, ($0 = 2:Int32), 2:Int32::Decimal, 0.0:Decimal)] }
        BatchScan { table: t, columns: [v1] }
  stream_plan: |
    StreamMaterialize { columns: [expr, _row_id(hidden)], pk_columns: [_row_id] }
      StreamProject { exprs: [Case(($0 = 1:Int32), 1:Int32::Decimal, ($0 = 2:Int32), 2:Int32::Decimal, 0.0:Decimal), $1] }
        StreamTableScan { table: t, columns: [v1, _row_id], pk_indices: [1] }
- sql: |
    /* case searched form without else */
    create table t (v1 int);
    select (case when v1=1 then 1 when v1=2 then 2.1 end) from t;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [Case(($0 = 1:Int32), 1:Int32::Decimal, ($0 = 2:Int32), 2.1:Decimal)] }
        BatchScan { table: t, columns: [v1] }
- sql: |
    /* case simple form */
    create table t (v1 int);
    select (case v1 when 1 then 1 when 2.0 then 2 else 0.0 end) from t;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [Case(($0 = 1:Int32), 1:Int32::Decimal, ($0 = 2.0:Decimal), 2:Int32::Decimal, 0.0:Decimal)] }
        BatchScan { table: t, columns: [v1] }
- sql: |
    /* case misaligned result types */
    create table t (v1 int);
    select (case when v1=1 then 1 when v1=2 then 2 else true end) from t;
  binder_error: 'Bind error: types Int32 and Boolean cannot be matched'
- sql: |
    /* case misaligned value types */
    create table t (v1 int);
    select (case v1 when 1 then 1 when true then 2 else 0.0 end) from t;
  binder_error: 'Feature is not yet implemented: Equal[Int32, Boolean], Tracking issue: https://github.com/singularity-data/piestream/issues/112'
- sql: |
    create table t (v1 int);
    select nullif(v1, 1) as expr from t;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [Case(($0 = 1:Int32), null:Int32, $0)] }
        BatchScan { table: t, columns: [v1] }
  stream_plan: |
    StreamMaterialize { columns: [expr, _row_id(hidden)], pk_columns: [_row_id] }
      StreamProject { exprs: [Case(($0 = 1:Int32), null:Int32, $0), $1] }
        StreamTableScan { table: t, columns: [v1, _row_id], pk_indices: [1] }
- sql: |
    create table t (v1 int);
    select nullif(v1, 1, 2) from t;
  binder_error: 'Bind error: Nullif function must contain 2 arguments'
- sql: |
    create table t (v1 int);
    select nullif(v1, true) from t;
  binder_error: 'Feature is not yet implemented: Equal[Int32, Boolean], Tracking issue: https://github.com/singularity-data/piestream/issues/112'
- sql: |
    create table t (v1 int);
    select coalesce(v1, 1) as expr from t;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [Coalesce($0, 1:Int32)] }
        BatchScan { table: t, columns: [v1] }
  stream_plan: |
    StreamMaterialize { columns: [expr, _row_id(hidden)], pk_columns: [_row_id] }
      StreamProject { exprs: [Coalesce($0, 1:Int32), $1] }
        StreamTableScan { table: t, columns: [v1, _row_id], pk_indices: [1] }
- sql: |
    create table t (v1 int);
    select coalesce(v1, 1.2) from t;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [Coalesce($0::Decimal, 1.2:Decimal)] }
        BatchScan { table: t, columns: [v1] }
- sql: |
    create table t (v1 int);
    select coalesce() from t;
  binder_error: 'Bind error: Function `Coalesce` takes at least 1 arguments (0 given)'
- sql: |
    create table t (v1 int);
    select coalesce(1,true) from t;
  binder_error: 'Bind error: types Int32 and Boolean cannot be matched'
- sql: |
    create table t (v1 varchar);
    select concat_ws(v1, 1) as expr from t;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [ConcatWs($0, 1:Int32::Varchar)] }
        BatchScan { table: t, columns: [v1] }
  stream_plan: |
    StreamMaterialize { columns: [expr, _row_id(hidden)], pk_columns: [_row_id] }
      StreamProject { exprs: [ConcatWs($0, 1:Int32::Varchar), $1] }
        StreamTableScan { table: t, columns: [v1, _row_id], pk_indices: [1] }
- sql: |
    create table t (v1 varchar);
    select concat_ws(v1, 1.2) from t;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [ConcatWs($0, 1.2:Decimal::Varchar)] }
        BatchScan { table: t, columns: [v1] }
- sql: |
    create table t (v1 int);
    select concat_ws(v1, 1.2) from t;
  binder_error: 'Bind error: cannot cast type Int32 to Varchar in Implicit context'
- sql: |
    create table t (v1 int);
    select concat_ws() from t;
  binder_error: 'Bind error: Function `ConcatWs` takes at least 2 arguments (0 given)'
- sql: |
    create table t (v1 varchar, v2 int, v3 float);
    select concat(v1, v2, v3, 1) as expr from t;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [ConcatWs('':Varchar, $0, $1::Varchar, $2::Varchar, 1:Int32::Varchar)] }
        BatchScan { table: t, columns: [v1, v2, v3] }
  stream_plan: |
    StreamMaterialize { columns: [expr, _row_id(hidden)], pk_columns: [_row_id] }
      StreamProject { exprs: [ConcatWs('':Varchar, $0, $1::Varchar, $2::Varchar, 1:Int32::Varchar), $3] }
        StreamTableScan { table: t, columns: [v1, v2, v3, _row_id], pk_indices: [3] }
- sql: |
    create table t (v1 float);
    select concat(v1) from t;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchProject { exprs: [ConcatWs('':Varchar, $0::Varchar)] }
        BatchScan { table: t, columns: [v1] }
- sql: |
    create table t (v1 int);
    select concat() from t;
  binder_error: 'Bind error: Function `Concat` takes at least 1 arguments (0 given)'
- sql: |
    select concat(':', true);
  batch_plan: |
    BatchProject { exprs: [ConcatWs('':Varchar, ':':Varchar, BoolOut(true:Boolean))] }
      BatchValues { rows: [[]] }
- sql: |
    select ':' || true;
  batch_plan: |
    BatchProject { exprs: [ConcatOp(':':Varchar, true:Boolean::Varchar)] }
      BatchValues { rows: [[]] }
- sql: |
    select substr('hello', NULL);
  batch_plan: |
    BatchProject { exprs: [Substr('hello':Varchar, null:Int32)] }
      BatchValues { rows: [[]] }
- sql: |
    select substr(NULL, 1);
  batch_plan: |
    BatchProject { exprs: [Substr(null:Varchar, 1:Int32)] }
      BatchValues { rows: [[]] }
- sql: |
    select pg_typeof('123');
  batch_plan: |
    BatchProject { exprs: ['unknown':Varchar] }
      BatchValues { rows: [[]] }
- sql: |
    select pg_typeof(round(null));
  batch_plan: |
    BatchProject { exprs: ['double precision':Varchar] }
      BatchValues { rows: [[]] }
- sql: |
    select pg_typeof(row(true, 1, 'hello'));
  batch_plan: |
    BatchProject { exprs: ['record':Varchar] }
      BatchValues { rows: [[]] }
- sql: |
    select pg_typeof(array[1, 2]);
  batch_plan: |
    BatchProject { exprs: ['integer[]':Varchar] }
      BatchValues { rows: [[]] }
- sql: |
    select pg_typeof(array[array[1, 2], array[3, 4]]);
  batch_plan: |
    BatchProject { exprs: ['integer[][]':Varchar] }
      BatchValues { rows: [[]] }
