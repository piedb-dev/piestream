- id: create_tables
  sql: |
    CREATE TABLE supplier (
            s_suppkey  INTEGER,
            s_name VARCHAR(25),
            s_address VARCHAR(40),
            s_nationkey INTEGER,
            s_phone VARCHAR(15),
            s_acctbal NUMERIC,
            s_comment VARCHAR(101));

    CREATE TABLE part (
            p_partkey INTEGER,
            p_name VARCHAR(55),
            p_mfgr VARCHAR(25),
            p_brand VARCHAR(10),
            p_type VARCHAR(100),
            p_size INTEGER,
            p_container VARCHAR(10),
            p_retailprice NUMERIC,
            p_comment VARCHAR(23));

    CREATE TABLE partsupp (
            ps_partkey INTEGER,
            ps_suppkey INTEGER,
            ps_availqty INTEGER,
            ps_supplycost NUMERIC,
            ps_comment VARCHAR(199));

    CREATE TABLE customer (
            c_custkey INTEGER,
            c_name VARCHAR(25),
            c_address VARCHAR(40),
            c_nationkey INTEGER,
            c_phone VARCHAR(15),
            c_acctbal NUMERIC,
            c_mktsegment VARCHAR(10),
            c_comment VARCHAR(117));

    CREATE TABLE orders (
            o_orderkey BIGINT,
            o_custkey INTEGER,
            o_orderstatus VARCHAR(1),
            o_totalprice NUMERIC,
            o_orderdate DATE,
            o_orderpriority VARCHAR(15),
            o_clerk VARCHAR(15),
            o_shippriority INTEGER,
            o_comment VARCHAR(79));

    CREATE TABLE lineitem (
            l_orderkey BIGINT,
            l_partkey INTEGER,
            l_suppkey INTEGER,
            l_linenumber INTEGER,
            l_quantity NUMERIC,
            l_extendedprice NUMERIC,
            l_discount NUMERIC,
            l_tax NUMERIC,
            l_returnflag VARCHAR(1),
            l_linestatus VARCHAR(1),
            l_shipdate DATE,
            l_commitdate DATE,
            l_receiptdate DATE,
            l_shipinstruct VARCHAR(25),
            l_shipmode VARCHAR(10),
            l_comment VARCHAR(44));

    CREATE TABLE nation (
            n_nationkey INTEGER,
            n_name VARCHAR(25),
            n_regionkey INTEGER,
            n_comment VARCHAR(152));

    CREATE TABLE region (
            r_regionkey INTEGER,
            r_name VARCHAR(25),
            r_comment VARCHAR(152));
- id: tpch_q1
  before:
    - create_tables
  sql: |
    select
      l_returnflag,
      l_linestatus,
      sum(l_quantity) as sum_qty,
      sum(l_extendedprice) as sum_base_price,
      sum(l_extendedprice * (1 - l_discount)) as sum_disc_price,
      sum(l_extendedprice * (1 - l_discount) * (1 + l_tax)) as sum_charge,
      round(avg(l_quantity), 4) as avg_qty,
      round(avg(l_extendedprice), 4) as avg_price,
      round(avg(l_discount), 4) as avg_disc,
      count(*) as count_order
    from
      lineitem
    where
      l_shipdate <= date '1998-12-01' - interval '71' day
    group by
      l_returnflag,
      l_linestatus
    order by
      l_returnflag,
      l_linestatus;
  batch_plan: |
    BatchExchange { order: [$0 ASC, $1 ASC], dist: Single }
      BatchSort { order: [$0 ASC, $1 ASC] }
        BatchProject { exprs: [$0, $1, $2, $3, $4, $5, RoundDigit(($6 / $7), 4:Int32), RoundDigit(($8 / $9), 4:Int32), RoundDigit(($10 / $11), 4:Int32), $12] }
          BatchHashAgg { group_keys: [$0, $1], aggs: [sum($2), sum($3), sum($4), sum($5), sum($2), count($2), sum($3), count($3), sum($6), count($6), count] }
            BatchProject { exprs: [$4, $5, $0, $1, ($1 * (1:Int32 - $2)), (($1 * (1:Int32 - $2)) * (1:Int32 + $3)), $2] }
              BatchExchange { order: [], dist: HashShard([4, 5]) }
                BatchFilter { predicate: ($6 <= ('1998-12-01':Varchar::Date - '71 days 00:00:00':Interval)) }
                  BatchScan { table: lineitem, columns: [l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate] }
  stream_plan: |
    StreamMaterialize { columns: [l_returnflag, l_linestatus, sum_qty, sum_base_price, sum_disc_price, sum_charge, avg_qty, avg_price, avg_disc, count_order], pk_columns: [l_returnflag, l_linestatus] }
      StreamProject { exprs: [$0, $1, $3, $4, $5, $6, RoundDigit(($7 / $8), 4:Int32), RoundDigit(($9 / $10), 4:Int32), RoundDigit(($11 / $12), 4:Int32), $13] }
        StreamHashAgg { group_keys: [$0, $1], aggs: [count, sum($2), sum($3), sum($4), sum($5), sum($2), count($2), sum($3), count($3), sum($6), count($6), count] }
          StreamProject { exprs: [$4, $5, $0, $1, ($1 * (1:Int32 - $2)), (($1 * (1:Int32 - $2)) * (1:Int32 + $3)), $2, $7] }
            StreamExchange { dist: HashShard([4, 5]) }
              StreamFilter { predicate: ($6 <= ('1998-12-01':Varchar::Date - '71 days 00:00:00':Interval)) }
                StreamTableScan { table: lineitem, columns: [l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, _row_id], pk_indices: [7] }
- id: tpch_q2
  before:
    - create_tables
  sql: |
    select
        s_acctbal,
        s_name,
        n_name,
        p_partkey,
        p_mfgr,
        s_address,
        s_phone,
        s_comment
    from
        partsupp,
        part,
        supplier,
     /* TODO(#1866): join reorder to avoid cross join */
     /* partsupp, */
        nation,
        region
    where
            p_partkey = ps_partkey
            and s_suppkey = ps_suppkey
      and p_size = 4
      and p_type like '%TIN'
            and s_nationkey = n_nationkey
            and n_regionkey = r_regionkey
            and r_name = 'AFRICA'
            and ps_supplycost = (
                    select
                            min(ps_supplycost)
                    from
                            partsupp,
                            supplier,
                            nation,
                            region
                    where
                            p_partkey = ps_partkey
                            and s_suppkey = ps_suppkey
                            and s_nationkey = n_nationkey
                            and n_regionkey = r_regionkey
                            and r_name = 'AFRICA'
            )
    order by
          s_acctbal desc,
          n_name,
          s_name,
          p_partkey
    limit 100;
  batch_plan: |
    BatchTopN { order: [$0 DESC, $2 ASC, $1 ASC, $3 ASC], limit: 100, offset: 0 }
      BatchExchange { order: [], dist: Single }
        BatchProject { exprs: [$6, $3, $8, $1, $2, $4, $5, $7] }
          BatchFilter { predicate: ($0 = $9) }
            BatchProject { exprs: [$4, $7, $9, $18, $19, $21, $22, $23, $26, $33] }
              BatchHashAgg { group_keys: [$0, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31, $32], aggs: [min($33)] }
                BatchProject { exprs: [$0, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31, $32, $33] }
                  BatchHashJoin { type: LeftOuter, predicate: $7 = $34 }
                    BatchExchange { order: [], dist: HashShard([7]) }
                      BatchHashJoin { type: Inner, predicate: $27 = $30 }
                        BatchExchange { order: [], dist: HashShard([27]) }
                          BatchHashJoin { type: Inner, predicate: $20 = $25 }
                            BatchExchange { order: [], dist: HashShard([20]) }
                              BatchHashJoin { type: Inner, predicate: $2 = $17 }
                                BatchExchange { order: [], dist: HashShard([2]) }
                                  BatchHashJoin { type: Inner, predicate: $1 = $7 }
                                    BatchExchange { order: [], dist: HashShard([1]) }
                                      BatchScan { table: partsupp, columns: [_row_id, ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment] }
                                    BatchExchange { order: [], dist: HashShard([1]) }
                                      BatchFilter { predicate: ($6 = 4:Int32) AND Like($5, '%TIN':Varchar) }
                                        BatchScan { table: part, columns: [_row_id, p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment] }
                                BatchExchange { order: [], dist: HashShard([1]) }
                                  BatchScan { table: supplier, columns: [_row_id, s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment] }
                            BatchExchange { order: [], dist: HashShard([1]) }
                              BatchScan { table: nation, columns: [_row_id, n_nationkey, n_name, n_regionkey, n_comment] }
                        BatchExchange { order: [], dist: HashShard([1]) }
                          BatchFilter { predicate: ($2 = 'AFRICA':Varchar) }
                            BatchScan { table: region, columns: [_row_id, r_regionkey, r_name, r_comment] }
                    BatchProject { exprs: [$1, $0] }
                      BatchExchange { order: [], dist: HashShard([0]) }
                        BatchHashJoin { type: Inner, predicate: $2 = $3 }
                          BatchProject { exprs: [$0, $1, $4] }
                            BatchExchange { order: [], dist: HashShard([4]) }
                              BatchHashJoin { type: Inner, predicate: $2 = $3 }
                                BatchProject { exprs: [$0, $2, $4] }
                                  BatchExchange { order: [], dist: HashShard([4]) }
                                    BatchHashJoin { type: Inner, predicate: $1 = $3 }
                                      BatchExchange { order: [], dist: HashShard([1]) }
                                        BatchScan { table: partsupp, columns: [ps_partkey, ps_suppkey, ps_supplycost] }
                                      BatchExchange { order: [], dist: HashShard([0]) }
                                        BatchScan { table: supplier, columns: [s_suppkey, s_nationkey] }
                                BatchExchange { order: [], dist: HashShard([0]) }
                                  BatchScan { table: nation, columns: [n_nationkey, n_regionkey] }
                          BatchProject { exprs: [$0] }
                            BatchExchange { order: [], dist: HashShard([0]) }
                              BatchFilter { predicate: ($1 = 'AFRICA':Varchar) }
                                BatchScan { table: region, columns: [r_regionkey, r_name] }
  stream_plan: |
    StreamMaterialize { columns: [s_acctbal, s_name, n_name, p_partkey, p_mfgr, s_address, s_phone, s_comment, _row_id(hidden), ps_partkey(hidden), ps_suppkey(hidden), ps_availqty(hidden), ps_supplycost(hidden), ps_comment(hidden), _row_id#1(hidden), p_name(hidden), p_brand(hidden), p_type(hidden), p_size(hidden), p_container(hidden), p_retailprice(hidden), p_comment(hidden), _row_id#2(hidden), s_suppkey(hidden), s_nationkey(hidden), _row_id#3(hidden), n_nationkey(hidden), n_regionkey(hidden), n_comment(hidden), _row_id#4(hidden), r_regionkey(hidden), r_name(hidden), r_comment(hidden)], pk_columns: [_row_id, ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id#1, p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id#2, s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment, _row_id#3, n_nationkey, n_name, n_regionkey, n_comment, _row_id#4, r_regionkey, r_name, r_comment], order_descs: [s_acctbal, n_name, s_name, p_partkey, _row_id, ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment, _row_id#1, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment, _row_id#2, s_suppkey, s_address, s_nationkey, s_phone, s_comment, _row_id#3, n_nationkey, n_regionkey, n_comment, _row_id#4, r_regionkey, r_name, r_comment] }
      StreamTopN { order: [$0 DESC, $2 ASC, $1 ASC, $3 ASC], limit: 100, offset: 0 }
        StreamExchange { dist: Single }
          StreamProject { exprs: [$6, $3, $8, $1, $2, $4, $5, $7, $10, $11, $12, $13, $0, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31, $32, $33] }
            StreamFilter { predicate: ($0 = $9) }
              StreamProject { exprs: [$4, $7, $9, $18, $19, $21, $22, $23, $26, $34, $0, $1, $2, $3, $5, $6, $8, $10, $11, $12, $13, $14, $15, $16, $17, $20, $24, $25, $27, $28, $29, $30, $31, $32] }
                StreamHashAgg { group_keys: [$0, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31, $32], aggs: [count, min($33)] }
                  StreamProject { exprs: [$0, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31, $32, $33, $35, $36, $37, $38] }
                    StreamHashJoin { type: LeftOuter, predicate: $7 = $34 }
                      StreamExchange { dist: HashShard([7]) }
                        StreamHashJoin { type: Inner, predicate: $27 = $30 }
                          StreamExchange { dist: HashShard([27]) }
                            StreamHashJoin { type: Inner, predicate: $20 = $25 }
                              StreamExchange { dist: HashShard([20]) }
                                StreamHashJoin { type: Inner, predicate: $2 = $17 }
                                  StreamExchange { dist: HashShard([2]) }
                                    StreamHashJoin { type: Inner, predicate: $1 = $7 }
                                      StreamExchange { dist: HashShard([1]) }
                                        StreamTableScan { table: partsupp, columns: [_row_id, ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment], pk_indices: [0] }
                                      StreamExchange { dist: HashShard([1]) }
                                        StreamFilter { predicate: ($6 = 4:Int32) AND Like($5, '%TIN':Varchar) }
                                          StreamTableScan { table: part, columns: [_row_id, p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment], pk_indices: [0] }
                                  StreamExchange { dist: HashShard([1]) }
                                    StreamTableScan { table: supplier, columns: [_row_id, s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment], pk_indices: [0] }
                              StreamExchange { dist: HashShard([1]) }
                                StreamTableScan { table: nation, columns: [_row_id, n_nationkey, n_name, n_regionkey, n_comment], pk_indices: [0] }
                          StreamExchange { dist: HashShard([1]) }
                            StreamFilter { predicate: ($2 = 'AFRICA':Varchar) }
                              StreamTableScan { table: region, columns: [_row_id, r_regionkey, r_name, r_comment], pk_indices: [0] }
                      StreamProject { exprs: [$1, $0, $3, $4, $5, $7] }
                        StreamExchange { dist: HashShard([0]) }
                          StreamHashJoin { type: Inner, predicate: $2 = $6 }
                            StreamProject { exprs: [$0, $1, $6, $3, $4, $7] }
                              StreamExchange { dist: HashShard([6]) }
                                StreamHashJoin { type: Inner, predicate: $2 = $5 }
                                  StreamProject { exprs: [$0, $2, $5, $3, $6] }
                                    StreamExchange { dist: HashShard([5]) }
                                      StreamHashJoin { type: Inner, predicate: $1 = $4 }
                                        StreamExchange { dist: HashShard([1]) }
                                          StreamTableScan { table: partsupp, columns: [ps_partkey, ps_suppkey, ps_supplycost, _row_id], pk_indices: [3] }
                                        StreamExchange { dist: HashShard([0]) }
                                          StreamTableScan { table: supplier, columns: [s_suppkey, s_nationkey, _row_id], pk_indices: [2] }
                                  StreamExchange { dist: HashShard([0]) }
                                    StreamTableScan { table: nation, columns: [n_nationkey, n_regionkey, _row_id], pk_indices: [2] }
                            StreamProject { exprs: [$0, $2] }
                              StreamExchange { dist: HashShard([0]) }
                                StreamFilter { predicate: ($1 = 'AFRICA':Varchar) }
                                  StreamTableScan { table: region, columns: [r_regionkey, r_name, _row_id], pk_indices: [2] }
- id: tpch_q3
  before:
    - create_tables
  sql: |
    select
      l_orderkey,
      sum(l_extendedprice * (1 - l_discount)) as revenue,
      o_orderdate,
      o_shippriority
    from
      customer,
      orders,
      lineitem
    where
      c_mktsegment = 'FURNITURE'
      and c_custkey = o_custkey
      and l_orderkey = o_orderkey
      and o_orderdate < date '1995-03-29'
      and l_shipdate > date '1995-03-29'
    group by
      l_orderkey,
      o_orderdate,
      o_shippriority
    order by
      revenue desc,
      o_orderdate
    limit 10;
  batch_plan: |
    BatchTopN { order: [$1 DESC, $2 ASC], limit: 10, offset: 0 }
      BatchExchange { order: [], dist: Single }
        BatchProject { exprs: [$0, $3, $1, $2] }
          BatchHashAgg { group_keys: [$0, $1, $2], aggs: [sum($3)] }
            BatchProject { exprs: [$3, $1, $2, ($4 * (1:Int32 - $5))] }
              BatchExchange { order: [], dist: HashShard([3, 1, 2]) }
                BatchHashJoin { type: Inner, predicate: $0 = $3 }
                  BatchProject { exprs: [$1, $3, $4] }
                    BatchExchange { order: [], dist: HashShard([1]) }
                      BatchHashJoin { type: Inner, predicate: $0 = $2 }
                        BatchProject { exprs: [$0] }
                          BatchExchange { order: [], dist: HashShard([0]) }
                            BatchFilter { predicate: ($1 = 'FURNITURE':Varchar) }
                              BatchScan { table: customer, columns: [c_custkey, c_mktsegment] }
                        BatchExchange { order: [], dist: HashShard([1]) }
                          BatchFilter { predicate: ($2 < '1995-03-29':Varchar::Date) }
                            BatchScan { table: orders, columns: [o_orderkey, o_custkey, o_orderdate, o_shippriority] }
                  BatchProject { exprs: [$0, $1, $2] }
                    BatchExchange { order: [], dist: HashShard([0]) }
                      BatchFilter { predicate: ($3 > '1995-03-29':Varchar::Date) }
                        BatchScan { table: lineitem, columns: [l_orderkey, l_extendedprice, l_discount, l_shipdate] }
  stream_plan: |
    StreamMaterialize { columns: [l_orderkey, revenue, o_orderdate, o_shippriority], pk_columns: [l_orderkey, o_orderdate, o_shippriority], order_descs: [revenue, o_orderdate, l_orderkey, o_shippriority] }
      StreamTopN { order: [$1 DESC, $2 ASC], limit: 10, offset: 0 }
        StreamExchange { dist: Single }
          StreamProject { exprs: [$0, $4, $1, $2] }
            StreamHashAgg { group_keys: [$0, $1, $2], aggs: [count, sum($3)] }
              StreamProject { exprs: [$5, $1, $2, ($6 * (1:Int32 - $7)), $3, $4, $8] }
                StreamExchange { dist: HashShard([5, 1, 2]) }
                  StreamHashJoin { type: Inner, predicate: $0 = $5 }
                    StreamProject { exprs: [$2, $4, $5, $1, $6] }
                      StreamExchange { dist: HashShard([2]) }
                        StreamHashJoin { type: Inner, predicate: $0 = $3 }
                          StreamProject { exprs: [$0, $2] }
                            StreamExchange { dist: HashShard([0]) }
                              StreamFilter { predicate: ($1 = 'FURNITURE':Varchar) }
                                StreamTableScan { table: customer, columns: [c_custkey, c_mktsegment, _row_id], pk_indices: [2] }
                          StreamExchange { dist: HashShard([1]) }
                            StreamFilter { predicate: ($2 < '1995-03-29':Varchar::Date) }
                              StreamTableScan { table: orders, columns: [o_orderkey, o_custkey, o_orderdate, o_shippriority, _row_id], pk_indices: [4] }
                    StreamProject { exprs: [$0, $1, $2, $4] }
                      StreamExchange { dist: HashShard([0]) }
                        StreamFilter { predicate: ($3 > '1995-03-29':Varchar::Date) }
                          StreamTableScan { table: lineitem, columns: [l_orderkey, l_extendedprice, l_discount, l_shipdate, _row_id], pk_indices: [4] }
- id: tpch_q4
  before:
    - create_tables
  sql: |
    select
      o_orderpriority,
      count(*) as order_count
    from
      orders
    where
      o_orderdate >= date '1997-07-01'
      and o_orderdate < date '1997-07-01' + interval '3' month
      and exists (
        select
          *
        from
          lineitem
        where
          l_orderkey = o_orderkey
          and l_commitdate < l_receiptdate
      )
    group by
      o_orderpriority
    order by
      o_orderpriority;
  batch_plan: |
    BatchExchange { order: [$0 ASC], dist: Single }
      BatchSort { order: [$0 ASC] }
        BatchHashAgg { group_keys: [$0], aggs: [count] }
          BatchProject { exprs: [$1] }
            BatchExchange { order: [], dist: HashShard([1]) }
              BatchHashJoin { type: LeftSemi, predicate: $0 = $2 }
                BatchProject { exprs: [$0, $2] }
                  BatchExchange { order: [], dist: HashShard([0]) }
                    BatchFilter { predicate: ($1 >= '1997-07-01':Varchar::Date) AND ($1 < ('1997-07-01':Varchar::Date + '3 mons 00:00:00':Interval)) }
                      BatchScan { table: orders, columns: [o_orderkey, o_orderdate, o_orderpriority] }
                BatchProject { exprs: [$0] }
                  BatchExchange { order: [], dist: HashShard([0]) }
                    BatchFilter { predicate: ($1 < $2) }
                      BatchScan { table: lineitem, columns: [l_orderkey, l_commitdate, l_receiptdate] }
  stream_plan: |
    StreamMaterialize { columns: [o_orderpriority, agg#0(hidden), order_count], pk_columns: [o_orderpriority] }
      StreamHashAgg { group_keys: [$0], aggs: [count, count] }
        StreamProject { exprs: [$1, $2] }
          StreamExchange { dist: HashShard([1]) }
            StreamHashJoin { type: LeftSemi, predicate: $0 = $3 }
              StreamProject { exprs: [$0, $2, $3] }
                StreamExchange { dist: HashShard([0]) }
                  StreamFilter { predicate: ($1 >= '1997-07-01':Varchar::Date) AND ($1 < ('1997-07-01':Varchar::Date + '3 mons 00:00:00':Interval)) }
                    StreamTableScan { table: orders, columns: [o_orderkey, o_orderdate, o_orderpriority, _row_id], pk_indices: [3] }
              StreamProject { exprs: [$0, $3] }
                StreamExchange { dist: HashShard([0]) }
                  StreamFilter { predicate: ($1 < $2) }
                    StreamTableScan { table: lineitem, columns: [l_orderkey, l_commitdate, l_receiptdate, _row_id], pk_indices: [3] }
- id: tpch_q5
  before:
    - create_tables
  sql: |
    select
      n_name,
      sum(l_extendedprice * (1 - l_discount)) as revenue
    from
      customer,
      orders,
      lineitem,
      supplier,
      nation,
      region
    where
      c_custkey = o_custkey
      and l_orderkey = o_orderkey
      and l_suppkey = s_suppkey
      and c_nationkey = s_nationkey
      and s_nationkey = n_nationkey
      and n_regionkey = r_regionkey
      and r_name = 'MIDDLE EAST'
      and o_orderdate >= date '1994-01-01'
      and o_orderdate < date '1994-01-01' + interval '1' year
    group by
      n_name
    order by
      revenue desc;
  batch_plan: |
    BatchExchange { order: [$1 DESC], dist: Single }
      BatchSort { order: [$1 DESC] }
        BatchHashAgg { group_keys: [$0], aggs: [sum($1)] }
          BatchProject { exprs: [$2, ($0 * (1:Int32 - $1))] }
            BatchExchange { order: [], dist: HashShard([2]) }
              BatchHashJoin { type: Inner, predicate: $3 = $4 }
                BatchProject { exprs: [$1, $2, $4, $5] }
                  BatchExchange { order: [], dist: HashShard([5]) }
                    BatchHashJoin { type: Inner, predicate: $0 = $3 }
                      BatchProject { exprs: [$2, $5, $6] }
                        BatchExchange { order: [], dist: HashShard([2]) }
                          BatchHashJoin { type: Inner, predicate: $1 = $4 AND $0 = $3 }
                            BatchProject { exprs: [$1, $2, $3] }
                              BatchExchange { order: [], dist: HashShard([2, 1]) }
                                BatchHashJoin { type: Inner, predicate: $0 = $3 }
                                  BatchProject { exprs: [$1, $2] }
                                    BatchExchange { order: [], dist: HashShard([1]) }
                                      BatchHashJoin { type: Inner, predicate: $0 = $3 }
                                        BatchExchange { order: [], dist: HashShard([0]) }
                                          BatchScan { table: customer, columns: [c_custkey, c_nationkey] }
                                        BatchProject { exprs: [$0, $1] }
                                          BatchExchange { order: [], dist: HashShard([1]) }
                                            BatchFilter { predicate: ($2 >= '1994-01-01':Varchar::Date) AND ($2 < ('1994-01-01':Varchar::Date + '1 year 00:00:00':Interval)) }
                                              BatchScan { table: orders, columns: [o_orderkey, o_custkey, o_orderdate] }
                                  BatchExchange { order: [], dist: HashShard([1]) }
                                    BatchScan { table: supplier, columns: [s_suppkey, s_nationkey] }
                            BatchExchange { order: [], dist: HashShard([1, 0]) }
                              BatchScan { table: lineitem, columns: [l_orderkey, l_suppkey, l_extendedprice, l_discount] }
                      BatchExchange { order: [], dist: HashShard([0]) }
                        BatchScan { table: nation, columns: [n_nationkey, n_name, n_regionkey] }
                BatchProject { exprs: [$0] }
                  BatchExchange { order: [], dist: HashShard([0]) }
                    BatchFilter { predicate: ($1 = 'MIDDLE EAST':Varchar) }
                      BatchScan { table: region, columns: [r_regionkey, r_name] }
  stream_plan: |
    StreamMaterialize { columns: [n_name, agg#0(hidden), revenue], pk_columns: [n_name], order_descs: [revenue, n_name] }
      StreamHashAgg { group_keys: [$0], aggs: [count, sum($1)] }
        StreamProject { exprs: [$2, ($0 * (1:Int32 - $1)), $4, $5, $6, $7, $8, $10] }
          StreamExchange { dist: HashShard([2]) }
            StreamHashJoin { type: Inner, predicate: $3 = $9 }
              StreamProject { exprs: [$1, $2, $8, $9, $3, $4, $5, $6, $10] }
                StreamExchange { dist: HashShard([9]) }
                  StreamHashJoin { type: Inner, predicate: $0 = $7 }
                    StreamProject { exprs: [$2, $8, $9, $3, $4, $5, $10] }
                      StreamExchange { dist: HashShard([2]) }
                        StreamHashJoin { type: Inner, predicate: $1 = $7 AND $0 = $6 }
                          StreamProject { exprs: [$1, $4, $5, $2, $3, $6] }
                            StreamExchange { dist: HashShard([4, 1]) }
                              StreamHashJoin { type: Inner, predicate: $0 = $5 }
                                StreamProject { exprs: [$1, $3, $2, $5] }
                                  StreamExchange { dist: HashShard([1]) }
                                    StreamHashJoin { type: Inner, predicate: $0 = $4 }
                                      StreamExchange { dist: HashShard([0]) }
                                        StreamTableScan { table: customer, columns: [c_custkey, c_nationkey, _row_id], pk_indices: [2] }
                                      StreamProject { exprs: [$0, $1, $3] }
                                        StreamExchange { dist: HashShard([1]) }
                                          StreamFilter { predicate: ($2 >= '1994-01-01':Varchar::Date) AND ($2 < ('1994-01-01':Varchar::Date + '1 year 00:00:00':Interval)) }
                                            StreamTableScan { table: orders, columns: [o_orderkey, o_custkey, o_orderdate, _row_id], pk_indices: [3] }
                                StreamExchange { dist: HashShard([1]) }
                                  StreamTableScan { table: supplier, columns: [s_suppkey, s_nationkey, _row_id], pk_indices: [2] }
                          StreamExchange { dist: HashShard([1, 0]) }
                            StreamTableScan { table: lineitem, columns: [l_orderkey, l_suppkey, l_extendedprice, l_discount, _row_id], pk_indices: [4] }
                    StreamExchange { dist: HashShard([0]) }
                      StreamTableScan { table: nation, columns: [n_nationkey, n_name, n_regionkey, _row_id], pk_indices: [3] }
              StreamProject { exprs: [$0, $2] }
                StreamExchange { dist: HashShard([0]) }
                  StreamFilter { predicate: ($1 = 'MIDDLE EAST':Varchar) }
                    StreamTableScan { table: region, columns: [r_regionkey, r_name, _row_id], pk_indices: [2] }
- id: tpch_q6
  before:
    - create_tables
  sql: |
    select
      sum(l_extendedprice * l_discount) as revenue
    from
      lineitem
    where
      l_shipdate >= date '1994-01-01'
      and l_shipdate < date '1994-01-01' + interval '1' year
      and l_discount between 0.08 - 0.01 and 0.08 + 0.01
      and l_quantity < 24;
  batch_plan: |
    BatchSimpleAgg { aggs: [sum($0)] }
      BatchExchange { order: [], dist: Single }
        BatchProject { exprs: [($1 * $2)] }
          BatchFilter { predicate: ($3 >= '1994-01-01':Varchar::Date) AND ($3 < ('1994-01-01':Varchar::Date + '1 year 00:00:00':Interval)) AND ($2 >= (0.08:Decimal - 0.01:Decimal)) AND ($2 <= (0.08:Decimal + 0.01:Decimal)) AND ($0 < 24:Int32) }
            BatchScan { table: lineitem, columns: [l_quantity, l_extendedprice, l_discount, l_shipdate] }
  stream_plan: |
    StreamMaterialize { columns: [agg#0(hidden), revenue], pk_columns: [agg#0, revenue] }
      StreamSimpleAgg { aggs: [count, sum($0)] }
        StreamExchange { dist: Single }
          StreamProject { exprs: [($1 * $2), $4] }
            StreamFilter { predicate: ($3 >= '1994-01-01':Varchar::Date) AND ($3 < ('1994-01-01':Varchar::Date + '1 year 00:00:00':Interval)) AND ($2 >= (0.08:Decimal - 0.01:Decimal)) AND ($2 <= (0.08:Decimal + 0.01:Decimal)) AND ($0 < 24:Int32) }
              StreamTableScan { table: lineitem, columns: [l_quantity, l_extendedprice, l_discount, l_shipdate, _row_id], pk_indices: [4] }
- id: tpch_q7
  before:
    - create_tables
  sql: |
    select
      supp_nation,
      cust_nation,
      l_year,
      sum(volume) as revenue
    from
      (
        select
          n1.n_name as supp_nation,
          n2.n_name as cust_nation,
          extract(year from l_shipdate) as l_year,
          l_extendedprice * (1 - l_discount) as volume
        from
          supplier,
          lineitem,
          orders,
          customer,
          nation n1,
          nation n2
        where
          s_suppkey = l_suppkey
          and o_orderkey = l_orderkey
          and c_custkey = o_custkey
          and s_nationkey = n1.n_nationkey
          and c_nationkey = n2.n_nationkey
          and (
            (n1.n_name = 'ROMANIA' and n2.n_name = 'IRAN')
            or (n1.n_name = 'IRAN' and n2.n_name = 'ROMANIA')
          )
          and l_shipdate between date '1983-01-01' and date '2000-12-31'
      ) as shipping
    group by
      supp_nation,
      cust_nation,
      l_year
    order by
      supp_nation,
      cust_nation,
      l_year;
  batch_plan: |
    BatchExchange { order: [$0 ASC, $1 ASC, $2 ASC], dist: Single }
      BatchSort { order: [$0 ASC, $1 ASC, $2 ASC] }
        BatchHashAgg { group_keys: [$0, $1, $2], aggs: [sum($3)] }
          BatchExchange { order: [], dist: HashShard([0, 1, 2]) }
            BatchProject { exprs: [$3, $6, Extract('YEAR':Varchar, $2), ($0 * (1:Int32 - $1))] }
              BatchFilter { predicate: ((($3 = 'ROMANIA':Varchar) AND ($6 = 'IRAN':Varchar)) OR (($3 = 'IRAN':Varchar) AND ($6 = 'ROMANIA':Varchar))) }
                BatchHashJoin { type: Inner, predicate: $4 = $5 }
                  BatchProject { exprs: [$0, $1, $2, $3, $6] }
                    BatchExchange { order: [], dist: HashShard([6]) }
                      BatchHashJoin { type: Inner, predicate: $4 = $5 }
                        BatchProject { exprs: [$1, $2, $3, $4, $6] }
                          BatchExchange { order: [], dist: HashShard([6]) }
                            BatchHashJoin { type: Inner, predicate: $0 = $5 }
                              BatchProject { exprs: [$1, $2, $3, $4, $6] }
                                BatchExchange { order: [], dist: HashShard([1]) }
                                  BatchHashJoin { type: Inner, predicate: $0 = $5 }
                                    BatchProject { exprs: [$1, $2, $4, $5, $6] }
                                      BatchExchange { order: [], dist: HashShard([1]) }
                                        BatchHashJoin { type: Inner, predicate: $0 = $3 }
                                          BatchExchange { order: [], dist: HashShard([0]) }
                                            BatchScan { table: supplier, columns: [s_suppkey, s_nationkey] }
                                          BatchExchange { order: [], dist: HashShard([1]) }
                                            BatchFilter { predicate: ($4 >= '1983-01-01':Varchar::Date) AND ($4 <= '2000-12-31':Varchar::Date) }
                                              BatchScan { table: lineitem, columns: [l_orderkey, l_suppkey, l_extendedprice, l_discount, l_shipdate] }
                                    BatchExchange { order: [], dist: HashShard([0]) }
                                      BatchScan { table: nation, columns: [n_nationkey, n_name] }
                              BatchExchange { order: [], dist: HashShard([0]) }
                                BatchScan { table: orders, columns: [o_orderkey, o_custkey] }
                        BatchExchange { order: [], dist: HashShard([0]) }
                          BatchScan { table: customer, columns: [c_custkey, c_nationkey] }
                  BatchExchange { order: [], dist: HashShard([0]) }
                    BatchScan { table: nation, columns: [n_nationkey, n_name] }
  stream_plan: |
    StreamMaterialize { columns: [supp_nation, cust_nation, l_year, agg#0(hidden), revenue], pk_columns: [supp_nation, cust_nation, l_year] }
      StreamHashAgg { group_keys: [$0, $1, $2], aggs: [count, sum($3)] }
        StreamExchange { dist: HashShard([0, 1, 2]) }
          StreamProject { exprs: [$3, $11, Extract('YEAR':Varchar, $2), ($0 * (1:Int32 - $1)), $5, $6, $7, $8, $9, $12] }
            StreamFilter { predicate: ((($3 = 'ROMANIA':Varchar) AND ($11 = 'IRAN':Varchar)) OR (($3 = 'IRAN':Varchar) AND ($11 = 'ROMANIA':Varchar))) }
              StreamHashJoin { type: Inner, predicate: $4 = $10 }
                StreamProject { exprs: [$0, $1, $2, $3, $10, $5, $6, $7, $8, $11] }
                  StreamExchange { dist: HashShard([10]) }
                    StreamHashJoin { type: Inner, predicate: $4 = $9 }
                      StreamProject { exprs: [$1, $2, $3, $4, $9, $5, $6, $7, $10] }
                        StreamExchange { dist: HashShard([9]) }
                          StreamHashJoin { type: Inner, predicate: $0 = $8 }
                            StreamProject { exprs: [$1, $2, $3, $4, $8, $5, $6, $9] }
                              StreamExchange { dist: HashShard([1]) }
                                StreamHashJoin { type: Inner, predicate: $0 = $7 }
                                  StreamProject { exprs: [$1, $3, $5, $6, $7, $2, $8] }
                                    StreamExchange { dist: HashShard([1]) }
                                      StreamHashJoin { type: Inner, predicate: $0 = $4 }
                                        StreamExchange { dist: HashShard([0]) }
                                          StreamTableScan { table: supplier, columns: [s_suppkey, s_nationkey, _row_id], pk_indices: [2] }
                                        StreamExchange { dist: HashShard([1]) }
                                          StreamFilter { predicate: ($4 >= '1983-01-01':Varchar::Date) AND ($4 <= '2000-12-31':Varchar::Date) }
                                            StreamTableScan { table: lineitem, columns: [l_orderkey, l_suppkey, l_extendedprice, l_discount, l_shipdate, _row_id], pk_indices: [5] }
                                  StreamExchange { dist: HashShard([0]) }
                                    StreamTableScan { table: nation, columns: [n_nationkey, n_name, _row_id], pk_indices: [2] }
                            StreamExchange { dist: HashShard([0]) }
                              StreamTableScan { table: orders, columns: [o_orderkey, o_custkey, _row_id], pk_indices: [2] }
                      StreamExchange { dist: HashShard([0]) }
                        StreamTableScan { table: customer, columns: [c_custkey, c_nationkey, _row_id], pk_indices: [2] }
                StreamExchange { dist: HashShard([0]) }
                  StreamTableScan { table: nation, columns: [n_nationkey, n_name, _row_id], pk_indices: [2] }
- id: tpch_q8
  before:
    - create_tables
  sql: |
    select
      o_year,
      round(sum(case
        when nation = 'IRAN' then volume
        else 0
      end) / sum(volume), 6) as mkt_share
    from
      (
        select
          extract(year from o_orderdate) as o_year,
          l_extendedprice * (1 - l_discount) as volume,
          n2.n_name as nation
        from
          lineitem,
          part,
          supplier,
       /* TODO(#1866): join reorder to avoid cross join */
       /* lineitem, */
          orders,
          customer,
          nation n1,
          nation n2,
          region
        where
          p_partkey = l_partkey
          and s_suppkey = l_suppkey
          and l_orderkey = o_orderkey
          and o_custkey = c_custkey
          and c_nationkey = n1.n_nationkey
          and n1.n_regionkey = r_regionkey
          and r_name = 'ASIA'
          and s_nationkey = n2.n_nationkey
          and o_orderdate between date '1995-01-01' and date '1996-12-31'
          and p_type = 'PROMO ANODIZED STEEL'
      ) as all_nations
    group by
      o_year
    order by
      o_year;
  batch_plan: |
    BatchExchange { order: [$0 ASC], dist: Single }
      BatchSort { order: [$0 ASC] }
        BatchProject { exprs: [$0, RoundDigit(($1 / $2), 6:Int32)] }
          BatchHashAgg { group_keys: [$0], aggs: [sum($1), sum($2)] }
            BatchExchange { order: [], dist: HashShard([0]) }
              BatchProject { exprs: [Extract('YEAR':Varchar, $2), Case(($3 = 'IRAN':Varchar), ($0 * (1:Int32 - $1)), 0:Int32::Decimal), ($0 * (1:Int32 - $1))] }
                BatchHashJoin { type: Inner, predicate: $4 = $5 }
                  BatchProject { exprs: [$0, $1, $2, $3, $6] }
                    BatchExchange { order: [], dist: HashShard([6]) }
                      BatchHashJoin { type: Inner, predicate: $4 = $5 }
                        BatchProject { exprs: [$0, $1, $3, $4, $6] }
                          BatchExchange { order: [], dist: HashShard([6]) }
                            BatchHashJoin { type: Inner, predicate: $2 = $5 }
                              BatchProject { exprs: [$0, $1, $3, $4, $6] }
                                BatchExchange { order: [], dist: HashShard([3]) }
                                  BatchHashJoin { type: Inner, predicate: $2 = $5 }
                                    BatchProject { exprs: [$1, $2, $3, $5, $6] }
                                      BatchExchange { order: [], dist: HashShard([3]) }
                                        BatchHashJoin { type: Inner, predicate: $0 = $4 }
                                          BatchProject { exprs: [$0, $2, $3, $5] }
                                            BatchExchange { order: [], dist: HashShard([0]) }
                                              BatchHashJoin { type: Inner, predicate: $1 = $4 }
                                                BatchProject { exprs: [$0, $2, $3, $4] }
                                                  BatchExchange { order: [], dist: HashShard([2]) }
                                                    BatchHashJoin { type: Inner, predicate: $1 = $5 }
                                                      BatchExchange { order: [], dist: HashShard([1]) }
                                                        BatchScan { table: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_extendedprice, l_discount] }
                                                      BatchProject { exprs: [$0] }
                                                        BatchExchange { order: [], dist: HashShard([0]) }
                                                          BatchFilter { predicate: ($1 = 'PROMO ANODIZED STEEL':Varchar) }
                                                            BatchScan { table: part, columns: [p_partkey, p_type] }
                                                BatchExchange { order: [], dist: HashShard([0]) }
                                                  BatchScan { table: supplier, columns: [s_suppkey, s_nationkey] }
                                          BatchExchange { order: [], dist: HashShard([0]) }
                                            BatchFilter { predicate: ($2 >= '1995-01-01':Varchar::Date) AND ($2 <= '1996-12-31':Varchar::Date) }
                                              BatchScan { table: orders, columns: [o_orderkey, o_custkey, o_orderdate] }
                                    BatchExchange { order: [], dist: HashShard([0]) }
                                      BatchScan { table: nation, columns: [n_nationkey, n_name] }
                              BatchExchange { order: [], dist: HashShard([0]) }
                                BatchScan { table: customer, columns: [c_custkey, c_nationkey] }
                        BatchExchange { order: [], dist: HashShard([0]) }
                          BatchScan { table: nation, columns: [n_nationkey, n_regionkey] }
                  BatchProject { exprs: [$0] }
                    BatchExchange { order: [], dist: HashShard([0]) }
                      BatchFilter { predicate: ($1 = 'ASIA':Varchar) }
                        BatchScan { table: region, columns: [r_regionkey, r_name] }
  stream_plan: |
    StreamMaterialize { columns: [o_year, mkt_share], pk_columns: [o_year] }
      StreamProject { exprs: [$0, RoundDigit(($2 / $3), 6:Int32)] }
        StreamHashAgg { group_keys: [$0], aggs: [count, sum($1), sum($2)] }
          StreamExchange { dist: HashShard([0]) }
            StreamProject { exprs: [Extract('YEAR':Varchar, $2), Case(($3 = 'IRAN':Varchar), ($0 * (1:Int32 - $1)), 0:Int32::Decimal), ($0 * (1:Int32 - $1)), $5, $6, $7, $8, $9, $10, $11, $13] }
              StreamHashJoin { type: Inner, predicate: $4 = $12 }
                StreamProject { exprs: [$0, $1, $2, $3, $12, $5, $6, $7, $8, $9, $10, $13] }
                  StreamExchange { dist: HashShard([12]) }
                    StreamHashJoin { type: Inner, predicate: $4 = $11 }
                      StreamProject { exprs: [$0, $1, $3, $4, $11, $5, $6, $7, $8, $9, $12] }
                        StreamExchange { dist: HashShard([11]) }
                          StreamHashJoin { type: Inner, predicate: $2 = $10 }
                            StreamProject { exprs: [$0, $1, $3, $4, $10, $5, $6, $7, $8, $11] }
                              StreamExchange { dist: HashShard([3]) }
                                StreamHashJoin { type: Inner, predicate: $2 = $9 }
                                  StreamProject { exprs: [$1, $2, $3, $8, $9, $4, $5, $6, $10] }
                                    StreamExchange { dist: HashShard([3]) }
                                      StreamHashJoin { type: Inner, predicate: $0 = $7 }
                                        StreamProject { exprs: [$0, $2, $3, $7, $4, $5, $8] }
                                          StreamExchange { dist: HashShard([0]) }
                                            StreamHashJoin { type: Inner, predicate: $1 = $6 }
                                              StreamProject { exprs: [$0, $2, $3, $4, $5, $7] }
                                                StreamExchange { dist: HashShard([2]) }
                                                  StreamHashJoin { type: Inner, predicate: $1 = $6 }
                                                    StreamExchange { dist: HashShard([1]) }
                                                      StreamTableScan { table: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_extendedprice, l_discount, _row_id], pk_indices: [5] }
                                                    StreamProject { exprs: [$0, $2] }
                                                      StreamExchange { dist: HashShard([0]) }
                                                        StreamFilter { predicate: ($1 = 'PROMO ANODIZED STEEL':Varchar) }
                                                          StreamTableScan { table: part, columns: [p_partkey, p_type, _row_id], pk_indices: [2] }
                                              StreamExchange { dist: HashShard([0]) }
                                                StreamTableScan { table: supplier, columns: [s_suppkey, s_nationkey, _row_id], pk_indices: [2] }
                                        StreamExchange { dist: HashShard([0]) }
                                          StreamFilter { predicate: ($2 >= '1995-01-01':Varchar::Date) AND ($2 <= '1996-12-31':Varchar::Date) }
                                            StreamTableScan { table: orders, columns: [o_orderkey, o_custkey, o_orderdate, _row_id], pk_indices: [3] }
                                  StreamExchange { dist: HashShard([0]) }
                                    StreamTableScan { table: nation, columns: [n_nationkey, n_name, _row_id], pk_indices: [2] }
                            StreamExchange { dist: HashShard([0]) }
                              StreamTableScan { table: customer, columns: [c_custkey, c_nationkey, _row_id], pk_indices: [2] }
                      StreamExchange { dist: HashShard([0]) }
                        StreamTableScan { table: nation, columns: [n_nationkey, n_regionkey, _row_id], pk_indices: [2] }
                StreamProject { exprs: [$0, $2] }
                  StreamExchange { dist: HashShard([0]) }
                    StreamFilter { predicate: ($1 = 'ASIA':Varchar) }
                      StreamTableScan { table: region, columns: [r_regionkey, r_name, _row_id], pk_indices: [2] }
- id: tpch_q9
  before:
    - create_tables
  sql: |
    select
      nation,
      o_year,
      round(sum(amount), 2) as sum_profit
    from
      (
        select
          n_name as nation,
          extract(year from o_orderdate) as o_year,
          l_extendedprice * (1 - l_discount) - ps_supplycost * l_quantity as amount
        from
          lineitem,
          part,
          supplier,
       /* TODO(#1866): join reorder to avoid cross join */
       /* lineitem, */
          partsupp,
          orders,
          nation
        where
          s_suppkey = l_suppkey
          and ps_suppkey = l_suppkey
          and ps_partkey = l_partkey
          and p_partkey = l_partkey
          and o_orderkey = l_orderkey
          and s_nationkey = n_nationkey
          and p_name like '%yellow%'
      ) as profit
    group by
      nation,
      o_year
    order by
      nation,
      o_year desc;
  batch_plan: |
    BatchExchange { order: [$0 ASC, $1 DESC], dist: Single }
      BatchSort { order: [$0 ASC, $1 DESC] }
        BatchProject { exprs: [$0, $1, RoundDigit($2, 2:Int32)] }
          BatchHashAgg { group_keys: [$0, $1], aggs: [sum($2)] }
            BatchExchange { order: [], dist: HashShard([0, 1]) }
              BatchProject { exprs: [$7, Extract('YEAR':Varchar, $5), (($1 * (1:Int32 - $2)) - ($4 * $0))] }
                BatchHashJoin { type: Inner, predicate: $3 = $6 }
                  BatchProject { exprs: [$1, $2, $3, $4, $5, $7] }
                    BatchExchange { order: [], dist: HashShard([4]) }
                      BatchHashJoin { type: Inner, predicate: $0 = $6 }
                        BatchProject { exprs: [$0, $3, $4, $5, $6, $9] }
                          BatchExchange { order: [], dist: HashShard([0]) }
                            BatchHashJoin { type: Inner, predicate: $2 = $8 AND $1 = $7 }
                              BatchExchange { order: [], dist: HashShard([2, 1]) }
                                BatchProject { exprs: [$0, $1, $2, $3, $4, $5, $7] }
                                  BatchHashJoin { type: Inner, predicate: $2 = $6 }
                                    BatchProject { exprs: [$0, $1, $2, $3, $4, $5] }
                                      BatchExchange { order: [], dist: HashShard([2]) }
                                        BatchHashJoin { type: Inner, predicate: $1 = $6 }
                                          BatchExchange { order: [], dist: HashShard([1]) }
                                            BatchScan { table: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount] }
                                          BatchProject { exprs: [$0] }
                                            BatchExchange { order: [], dist: HashShard([0]) }
                                              BatchFilter { predicate: Like($1, '%yellow%':Varchar) }
                                                BatchScan { table: part, columns: [p_partkey, p_name] }
                                    BatchExchange { order: [], dist: HashShard([0]) }
                                      BatchScan { table: supplier, columns: [s_suppkey, s_nationkey] }
                              BatchExchange { order: [], dist: HashShard([1, 0]) }
                                BatchScan { table: partsupp, columns: [ps_partkey, ps_suppkey, ps_supplycost] }
                        BatchExchange { order: [], dist: HashShard([0]) }
                          BatchScan { table: orders, columns: [o_orderkey, o_orderdate] }
                  BatchExchange { order: [], dist: HashShard([0]) }
                    BatchScan { table: nation, columns: [n_nationkey, n_name] }
  stream_plan: |
    StreamMaterialize { columns: [nation, o_year, sum_profit], pk_columns: [nation, o_year] }
      StreamProject { exprs: [$0, $1, RoundDigit($3, 2:Int32)] }
        StreamHashAgg { group_keys: [$0, $1], aggs: [count, sum($2)] }
          StreamExchange { dist: HashShard([0, 1]) }
            StreamProject { exprs: [$12, Extract('YEAR':Varchar, $5), (($1 * (1:Int32 - $2)) - ($4 * $0)), $6, $7, $8, $9, $10, $13] }
              StreamHashJoin { type: Inner, predicate: $3 = $11 }
                StreamProject { exprs: [$1, $2, $3, $4, $5, $11, $6, $7, $8, $9, $12] }
                  StreamExchange { dist: HashShard([4]) }
                    StreamHashJoin { type: Inner, predicate: $0 = $10 }
                      StreamProject { exprs: [$0, $3, $4, $5, $6, $12, $7, $8, $9, $13] }
                        StreamExchange { dist: HashShard([0]) }
                          StreamHashJoin { type: Inner, predicate: $2 = $11 AND $1 = $10 }
                            StreamExchange { dist: HashShard([2, 1]) }
                              StreamProject { exprs: [$0, $1, $2, $3, $4, $5, $9, $6, $7, $10] }
                                StreamHashJoin { type: Inner, predicate: $2 = $8 }
                                  StreamProject { exprs: [$0, $1, $2, $3, $4, $5, $6, $8] }
                                    StreamExchange { dist: HashShard([2]) }
                                      StreamHashJoin { type: Inner, predicate: $1 = $7 }
                                        StreamExchange { dist: HashShard([1]) }
                                          StreamTableScan { table: lineitem, columns: [l_orderkey, l_partkey, l_suppkey, l_quantity, l_extendedprice, l_discount, _row_id], pk_indices: [6] }
                                        StreamProject { exprs: [$0, $2] }
                                          StreamExchange { dist: HashShard([0]) }
                                            StreamFilter { predicate: Like($1, '%yellow%':Varchar) }
                                              StreamTableScan { table: part, columns: [p_partkey, p_name, _row_id], pk_indices: [2] }
                                  StreamExchange { dist: HashShard([0]) }
                                    StreamTableScan { table: supplier, columns: [s_suppkey, s_nationkey, _row_id], pk_indices: [2] }
                            StreamExchange { dist: HashShard([1, 0]) }
                              StreamTableScan { table: partsupp, columns: [ps_partkey, ps_suppkey, ps_supplycost, _row_id], pk_indices: [3] }
                      StreamExchange { dist: HashShard([0]) }
                        StreamTableScan { table: orders, columns: [o_orderkey, o_orderdate, _row_id], pk_indices: [2] }
                StreamExchange { dist: HashShard([0]) }
                  StreamTableScan { table: nation, columns: [n_nationkey, n_name, _row_id], pk_indices: [2] }
- id: tpch_q10
  before:
    - create_tables
  sql: |
    select
      c_custkey,
      c_name,
      sum(l_extendedprice * (1.00 - l_discount)) as revenue,
      c_acctbal,
      n_name,
      c_address,
      c_phone,
      c_comment
    from
      customer,
      orders,
      lineitem,
      nation
    where
      c_custkey = o_custkey
      and l_orderkey = o_orderkey
      and o_orderdate >= date '1994-01-01'
      and o_orderdate < date '1994-01-01' + interval '3' month
      and l_returnflag = 'R'
      and c_nationkey = n_nationkey
    group by
      c_custkey,
      c_name,
      c_acctbal,
      c_phone,
      n_name,
      c_address,
      c_comment
    order by
      revenue desc
    limit 20;
  batch_plan: |
    BatchTopN { order: [$2 DESC], limit: 20, offset: 0 }
      BatchExchange { order: [], dist: Single }
        BatchProject { exprs: [$0, $1, $7, $2, $4, $5, $3, $6] }
          BatchHashAgg { group_keys: [$0, $1, $2, $3, $4, $5, $6], aggs: [sum($7)] }
            BatchProject { exprs: [$0, $1, $4, $3, $7, $2, $5, ($9 * (1.00:Decimal - $10))] }
              BatchExchange { order: [], dist: HashShard([0, 1, 4, 3, 7, 2, 5]) }
                BatchHashJoin { type: Inner, predicate: $6 = $8 }
                  BatchProject { exprs: [$0, $1, $2, $4, $5, $6, $7, $9] }
                    BatchExchange { order: [], dist: HashShard([7]) }
                      BatchHashJoin { type: Inner, predicate: $3 = $8 }
                        BatchProject { exprs: [$0, $1, $2, $3, $4, $5, $6, $7] }
                          BatchExchange { order: [], dist: HashShard([3]) }
                            BatchHashJoin { type: Inner, predicate: $0 = $8 }
                              BatchExchange { order: [], dist: HashShard([0]) }
                                BatchScan { table: customer, columns: [c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_comment] }
                              BatchProject { exprs: [$0, $1] }
                                BatchExchange { order: [], dist: HashShard([1]) }
                                  BatchFilter { predicate: ($2 >= '1994-01-01':Varchar::Date) AND ($2 < ('1994-01-01':Varchar::Date + '3 mons 00:00:00':Interval)) }
                                    BatchScan { table: orders, columns: [o_orderkey, o_custkey, o_orderdate] }
                        BatchExchange { order: [], dist: HashShard([0]) }
                          BatchScan { table: nation, columns: [n_nationkey, n_name] }
                  BatchProject { exprs: [$0, $1, $2] }
                    BatchExchange { order: [], dist: HashShard([0]) }
                      BatchFilter { predicate: ($3 = 'R':Varchar) }
                        BatchScan { table: lineitem, columns: [l_orderkey, l_extendedprice, l_discount, l_returnflag] }
  stream_plan: |
    StreamMaterialize { columns: [c_custkey, c_name, revenue, c_acctbal, n_name, c_address, c_phone, c_comment], pk_columns: [c_custkey, c_name, c_acctbal, c_phone, n_name, c_address, c_comment], order_descs: [revenue, c_custkey, c_name, c_acctbal, c_phone, n_name, c_address, c_comment] }
      StreamTopN { order: [$2 DESC], limit: 20, offset: 0 }
        StreamExchange { dist: Single }
          StreamProject { exprs: [$0, $1, $8, $2, $4, $5, $3, $6] }
            StreamHashAgg { group_keys: [$0, $1, $2, $3, $4, $5, $6], aggs: [count, sum($7)] }
              StreamProject { exprs: [$0, $1, $4, $3, $7, $2, $5, ($12 * (1.00:Decimal - $13)), $8, $9, $10, $14] }
                StreamExchange { dist: HashShard([0, 1, 4, 3, 7, 2, 5]) }
                  StreamHashJoin { type: Inner, predicate: $6 = $11 }
                    StreamProject { exprs: [$0, $1, $2, $4, $5, $6, $7, $11, $8, $9, $12] }
                      StreamExchange { dist: HashShard([7]) }
                        StreamHashJoin { type: Inner, predicate: $3 = $10 }
                          StreamProject { exprs: [$0, $1, $2, $3, $4, $5, $6, $8, $7, $10] }
                            StreamExchange { dist: HashShard([3]) }
                              StreamHashJoin { type: Inner, predicate: $0 = $9 }
                                StreamExchange { dist: HashShard([0]) }
                                  StreamTableScan { table: customer, columns: [c_custkey, c_name, c_address, c_nationkey, c_phone, c_acctbal, c_comment, _row_id], pk_indices: [7] }
                                StreamProject { exprs: [$0, $1, $3] }
                                  StreamExchange { dist: HashShard([1]) }
                                    StreamFilter { predicate: ($2 >= '1994-01-01':Varchar::Date) AND ($2 < ('1994-01-01':Varchar::Date + '3 mons 00:00:00':Interval)) }
                                      StreamTableScan { table: orders, columns: [o_orderkey, o_custkey, o_orderdate, _row_id], pk_indices: [3] }
                          StreamExchange { dist: HashShard([0]) }
                            StreamTableScan { table: nation, columns: [n_nationkey, n_name, _row_id], pk_indices: [2] }
                    StreamProject { exprs: [$0, $1, $2, $4] }
                      StreamExchange { dist: HashShard([0]) }
                        StreamFilter { predicate: ($3 = 'R':Varchar) }
                          StreamTableScan { table: lineitem, columns: [l_orderkey, l_extendedprice, l_discount, l_returnflag, _row_id], pk_indices: [4] }
- id: tpch_q11
  before:
    - create_tables
  sql: |
    select
      ps_partkey,
      sum(ps_supplycost * ps_availqty) as value
    from
      partsupp,
      supplier,
      nation
    where
      ps_suppkey = s_suppkey
      and s_nationkey = n_nationkey
      and n_name = 'ARGENTINA'
    group by
      ps_partkey
    having
      sum(ps_supplycost * ps_availqty) > (
        select
          sum(ps_supplycost * ps_availqty) * 0.0001000000
        from
          partsupp,
          supplier,
          nation
        where
          ps_suppkey = s_suppkey
          and s_nationkey = n_nationkey
          and n_name = 'ARGENTINA'
      )
    order by
      value desc;
  logical_plan: |
    LogicalProject { exprs: [$0, $1] }
      LogicalFilter { predicate: ($2 > $3) }
        LogicalJoin { type: LeftOuter, on: true }
          LogicalAgg { group_keys: [0], agg_calls: [sum($1), sum($1)] }
            LogicalProject { exprs: [$1, ($4 * $3)] }
              LogicalFilter { predicate: ($2 = $7) AND ($10 = $15) AND ($16 = 'ARGENTINA':Varchar) }
                LogicalJoin { type: Inner, on: true }
                  LogicalJoin { type: Inner, on: true }
                    LogicalScan { table: partsupp, columns: [_row_id, ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment] }
                    LogicalScan { table: supplier, columns: [_row_id, s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment] }
                  LogicalScan { table: nation, columns: [_row_id, n_nationkey, n_name, n_regionkey, n_comment] }
          LogicalProject { exprs: [($0 * 0.0001000000:Decimal)] }
            LogicalAgg { group_keys: [], agg_calls: [sum($0)] }
              LogicalProject { exprs: [($4 * $3)] }
                LogicalFilter { predicate: ($2 = $7) AND ($10 = $15) AND ($16 = 'ARGENTINA':Varchar) }
                  LogicalJoin { type: Inner, on: true }
                    LogicalJoin { type: Inner, on: true }
                      LogicalScan { table: partsupp, columns: [_row_id, ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment] }
                      LogicalScan { table: supplier, columns: [_row_id, s_suppkey, s_name, s_address, s_nationkey, s_phone, s_acctbal, s_comment] }
                    LogicalScan { table: nation, columns: [_row_id, n_nationkey, n_name, n_regionkey, n_comment] }
  optimized_logical_plan: |
    LogicalProject { exprs: [$0, $1] }
      LogicalJoin { type: Inner, on: ($2 > $3) }
        LogicalAgg { group_keys: [0], agg_calls: [sum($1), sum($1)] }
          LogicalProject { exprs: [$0, ($2 * $1)] }
            LogicalJoin { type: Inner, on: ($3 = $4) }
              LogicalProject { exprs: [$0, $2, $3, $5] }
                LogicalJoin { type: Inner, on: ($1 = $4) }
                  LogicalScan { table: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost] }
                  LogicalScan { table: supplier, columns: [s_suppkey, s_nationkey] }
              LogicalProject { exprs: [$0] }
                LogicalFilter { predicate: ($1 = 'ARGENTINA':Varchar) }
                  LogicalScan { table: nation, columns: [n_nationkey, n_name] }
        LogicalProject { exprs: [($0 * 0.0001000000:Decimal)] }
          LogicalAgg { group_keys: [], agg_calls: [sum($0)] }
            LogicalProject { exprs: [($1 * $0)] }
              LogicalJoin { type: Inner, on: ($2 = $3) }
                LogicalProject { exprs: [$1, $2, $4] }
                  LogicalJoin { type: Inner, on: ($0 = $3) }
                    LogicalScan { table: partsupp, columns: [ps_suppkey, ps_availqty, ps_supplycost] }
                    LogicalScan { table: supplier, columns: [s_suppkey, s_nationkey] }
                LogicalProject { exprs: [$0] }
                  LogicalFilter { predicate: ($1 = 'ARGENTINA':Varchar) }
                    LogicalScan { table: nation, columns: [n_nationkey, n_name] }
  batch_plan: |
    BatchSort { order: [$1 DESC] }
      BatchProject { exprs: [$0, $1] }
        BatchNestedLoopJoin { type: Inner, predicate: ($2 > $3) }
          BatchExchange { order: [], dist: Single }
            BatchHashAgg { group_keys: [$0], aggs: [sum($1), sum($1)] }
              BatchProject { exprs: [$0, ($2 * $1)] }
                BatchExchange { order: [], dist: HashShard([0]) }
                  BatchHashJoin { type: Inner, predicate: $3 = $4 }
                    BatchProject { exprs: [$0, $2, $3, $5] }
                      BatchExchange { order: [], dist: HashShard([5]) }
                        BatchHashJoin { type: Inner, predicate: $1 = $4 }
                          BatchExchange { order: [], dist: HashShard([1]) }
                            BatchScan { table: partsupp, columns: [ps_partkey, ps_suppkey, ps_availqty, ps_supplycost] }
                          BatchExchange { order: [], dist: HashShard([0]) }
                            BatchScan { table: supplier, columns: [s_suppkey, s_nationkey] }
                    BatchProject { exprs: [$0] }
                      BatchExchange { order: [], dist: HashShard([0]) }
                        BatchFilter { predicate: ($1 = 'ARGENTINA':Varchar) }
                          BatchScan { table: nation, columns: [n_nationkey, n_name] }
          BatchProject { exprs: [($0 * 0.0001000000:Decimal)] }
            BatchSimpleAgg { aggs: [sum($0)] }
              BatchExchange { order: [], dist: Single }
                BatchProject { exprs: [($1 * $0)] }
                  BatchHashJoin { type: Inner, predicate: $2 = $3 }
                    BatchProject { exprs: [$1, $2, $4] }
                      BatchExchange { order: [], dist: HashShard([4]) }
                        BatchHashJoin { type: Inner, predicate: $0 = $3 }
                          BatchExchange { order: [], dist: HashShard([0]) }
                            BatchScan { table: partsupp, columns: [ps_suppkey, ps_availqty, ps_supplycost] }
                          BatchExchange { order: [], dist: HashShard([0]) }
                            BatchScan { table: supplier, columns: [s_suppkey, s_nationkey] }
                    BatchProject { exprs: [$0] }
                      BatchExchange { order: [], dist: HashShard([0]) }
                        BatchFilter { predicate: ($1 = 'ARGENTINA':Varchar) }
                          BatchScan { table: nation, columns: [n_nationkey, n_name] }
- id: tpch_q12
  before:
    - create_tables
  sql: |
    select
        l_shipmode,
        sum(case
            when o_orderpriority = '1-URGENT'
                or o_orderpriority = '2-HIGH'
                then 1
            else 0
        end) as high_line_count,
        sum(case
            when o_orderpriority <> '1-URGENT'
                and o_orderpriority <> '2-HIGH'
                then 1
            else 0
        end) as low_line_count
    from
        orders,
        lineitem
    where
        o_orderkey = l_orderkey
        and l_shipmode in ('FOB', 'SHIP')
        and l_commitdate < l_receiptdate
        and l_shipdate < l_commitdate
        and l_receiptdate >= date '1994-01-01'
        and l_receiptdate < date '1994-01-01' + interval '1' year
    group by
        l_shipmode
    order by
        l_shipmode;
  batch_plan: |
    BatchExchange { order: [$0 ASC], dist: Single }
      BatchSort { order: [$0 ASC] }
        BatchHashAgg { group_keys: [$0], aggs: [sum($1), sum($2)] }
          BatchProject { exprs: [$3, Case((($1 = '1-URGENT':Varchar) OR ($1 = '2-HIGH':Varchar)), 1:Int32, 0:Int32), Case((($1 <> '1-URGENT':Varchar) AND ($1 <> '2-HIGH':Varchar)), 1:Int32, 0:Int32)] }
            BatchExchange { order: [], dist: HashShard([3]) }
              BatchHashJoin { type: Inner, predicate: $0 = $2 }
                BatchExchange { order: [], dist: HashShard([0]) }
                  BatchScan { table: orders, columns: [o_orderkey, o_orderpriority] }
                BatchProject { exprs: [$0, $4] }
                  BatchExchange { order: [], dist: HashShard([0]) }
                    BatchFilter { predicate: In($4, 'FOB':Varchar, 'SHIP':Varchar) AND ($2 < $3) AND ($1 < $2) AND ($3 >= '1994-01-01':Varchar::Date) AND ($3 < ('1994-01-01':Varchar::Date + '1 year 00:00:00':Interval)) }
                      BatchScan { table: lineitem, columns: [l_orderkey, l_shipdate, l_commitdate, l_receiptdate, l_shipmode] }
  stream_plan: |
    StreamMaterialize { columns: [l_shipmode, agg#0(hidden), high_line_count, low_line_count], pk_columns: [l_shipmode] }
      StreamHashAgg { group_keys: [$0], aggs: [count, sum($1), sum($2)] }
        StreamProject { exprs: [$4, Case((($1 = '1-URGENT':Varchar) OR ($1 = '2-HIGH':Varchar)), 1:Int32, 0:Int32), Case((($1 <> '1-URGENT':Varchar) AND ($1 <> '2-HIGH':Varchar)), 1:Int32, 0:Int32), $2, $5] }
          StreamExchange { dist: HashShard([4]) }
            StreamHashJoin { type: Inner, predicate: $0 = $3 }
              StreamExchange { dist: HashShard([0]) }
                StreamTableScan { table: orders, columns: [o_orderkey, o_orderpriority, _row_id], pk_indices: [2] }
              StreamProject { exprs: [$0, $4, $5] }
                StreamExchange { dist: HashShard([0]) }
                  StreamFilter { predicate: In($4, 'FOB':Varchar, 'SHIP':Varchar) AND ($2 < $3) AND ($1 < $2) AND ($3 >= '1994-01-01':Varchar::Date) AND ($3 < ('1994-01-01':Varchar::Date + '1 year 00:00:00':Interval)) }
                    StreamTableScan { table: lineitem, columns: [l_orderkey, l_shipdate, l_commitdate, l_receiptdate, l_shipmode, _row_id], pk_indices: [5] }
- id: tpch_q13
  before:
    - create_tables
  sql: |
    select
      c_count,
      count(*) as custdist
    from
      (
        select
          c_custkey,
          count(o_orderkey) as c_count
        from
          customer left outer join orders on
            c_custkey = o_custkey
            and o_comment not like '%:1%:2%'
        group by
          c_custkey
      ) as c_orders (c_custkey, c_count)
    group by
      c_count
    order by
      custdist desc,
      c_count desc;
  batch_plan: |
    BatchExchange { order: [$1 DESC, $0 DESC], dist: Single }
      BatchSort { order: [$1 DESC, $0 DESC] }
        BatchHashAgg { group_keys: [$0], aggs: [count] }
          BatchProject { exprs: [$1] }
            BatchExchange { order: [], dist: HashShard([1]) }
              BatchHashAgg { group_keys: [$0], aggs: [count($1)] }
                BatchProject { exprs: [$0, $1] }
                  BatchHashJoin { type: LeftOuter, predicate: $0 = $2 }
                    BatchExchange { order: [], dist: HashShard([0]) }
                      BatchScan { table: customer, columns: [c_custkey] }
                    BatchProject { exprs: [$0, $1] }
                      BatchExchange { order: [], dist: HashShard([1]) }
                        BatchFilter { predicate: Not(Like($2, '%:1%:2%':Varchar)) }
                          BatchScan { table: orders, columns: [o_orderkey, o_custkey, o_comment] }
  stream_plan: |
    StreamMaterialize { columns: [c_count, agg#0(hidden), custdist], pk_columns: [c_count], order_descs: [custdist, c_count] }
      StreamHashAgg { group_keys: [$0], aggs: [count, count] }
        StreamProject { exprs: [$2, $0] }
          StreamExchange { dist: HashShard([2]) }
            StreamHashAgg { group_keys: [$0], aggs: [count, count($1)] }
              StreamProject { exprs: [$0, $2, $1, $4] }
                StreamHashJoin { type: LeftOuter, predicate: $0 = $3 }
                  StreamExchange { dist: HashShard([0]) }
                    StreamTableScan { table: customer, columns: [c_custkey, _row_id], pk_indices: [1] }
                  StreamProject { exprs: [$0, $1, $3] }
                    StreamExchange { dist: HashShard([1]) }
                      StreamFilter { predicate: Not(Like($2, '%:1%:2%':Varchar)) }
                        StreamTableScan { table: orders, columns: [o_orderkey, o_custkey, o_comment, _row_id], pk_indices: [3] }
- id: tpch_q14
  before:
    - create_tables
  sql: |
    select
      100.00 * sum(case
        when p_type like 'PROMO%'
          then l_extendedprice * (1 - l_discount)
        else 0
      end) / sum(l_extendedprice * (1 - l_discount)) as promo_revenue
    from
      lineitem,
      part
    where
      l_partkey = p_partkey
      and l_shipdate >= date '1995-09-01'
      and l_shipdate < date '1995-09-01' + interval '1' month;
  batch_plan: |
    BatchProject { exprs: [((100.00:Decimal * $0) / $1)] }
      BatchSimpleAgg { aggs: [sum($0), sum($1)] }
        BatchExchange { order: [], dist: Single }
          BatchProject { exprs: [Case(Like($4, 'PROMO%':Varchar), ($1 * (1:Int32 - $2)), 0:Int32::Decimal), ($1 * (1:Int32 - $2))] }
            BatchHashJoin { type: Inner, predicate: $0 = $3 }
              BatchProject { exprs: [$0, $1, $2] }
                BatchExchange { order: [], dist: HashShard([0]) }
                  BatchFilter { predicate: ($3 >= '1995-09-01':Varchar::Date) AND ($3 < ('1995-09-01':Varchar::Date + '1 mon 00:00:00':Interval)) }
                    BatchScan { table: lineitem, columns: [l_partkey, l_extendedprice, l_discount, l_shipdate] }
              BatchExchange { order: [], dist: HashShard([0]) }
                BatchScan { table: part, columns: [p_partkey, p_type] }
  stream_plan: |
    StreamMaterialize { columns: [promo_revenue, agg#0(hidden), agg#1(hidden), agg#2(hidden)], pk_columns: [agg#0, agg#1, agg#2] }
      StreamProject { exprs: [((100.00:Decimal * $1) / $2), $0, $1, $2] }
        StreamSimpleAgg { aggs: [count, sum($0), sum($1)] }
          StreamExchange { dist: Single }
            StreamProject { exprs: [Case(Like($5, 'PROMO%':Varchar), ($1 * (1:Int32 - $2)), 0:Int32::Decimal), ($1 * (1:Int32 - $2)), $3, $6] }
              StreamHashJoin { type: Inner, predicate: $0 = $4 }
                StreamProject { exprs: [$0, $1, $2, $4] }
                  StreamExchange { dist: HashShard([0]) }
                    StreamFilter { predicate: ($3 >= '1995-09-01':Varchar::Date) AND ($3 < ('1995-09-01':Varchar::Date + '1 mon 00:00:00':Interval)) }
                      StreamTableScan { table: lineitem, columns: [l_partkey, l_extendedprice, l_discount, l_shipdate, _row_id], pk_indices: [4] }
                StreamExchange { dist: HashShard([0]) }
                  StreamTableScan { table: part, columns: [p_partkey, p_type, _row_id], pk_indices: [2] }
- id: tpch_q15
  before:
    - create_tables
  sql: |
    select
      s_suppkey,
      s_name,
      s_address,
      s_phone,
      total_revenue
    from
      supplier,
      (
        select
        l_suppkey,
        sum(l_extendedprice * (1 - l_discount)) as total_revenue
      from
        lineitem
      where
        l_shipdate >= date '1993-01-01'
        and l_shipdate < date '1993-01-01' + interval '3' month
      group by
        l_suppkey
      ) as revenue0 (supplier_no, total_revenue)
    where
      s_suppkey = supplier_no
      and total_revenue = (
        select
          max(total_revenue) as max_revenue
        from
          (
            select
            l_suppkey,
            sum(l_extendedprice * (1 - l_discount)) as total_revenue
          from
            lineitem
          where
            l_shipdate >= date '1993-01-01'
            and l_shipdate < date '1993-01-01' + interval '3' month
          group by
            l_suppkey
          ) as revenue0 (supplier_no, total_revenue)
      )
    order by
      s_suppkey;
  batch_plan: |
    BatchExchange { order: [$0 ASC], dist: Single }
      BatchSort { order: [$0 ASC] }
        BatchProject { exprs: [$0, $1, $2, $3, $4] }
          BatchHashJoin { type: Inner, predicate: $4 = $5 }
            BatchProject { exprs: [$0, $1, $2, $3, $5] }
              BatchExchange { order: [], dist: HashShard([5]) }
                BatchHashJoin { type: Inner, predicate: $0 = $4 }
                  BatchExchange { order: [], dist: HashShard([0]) }
                    BatchScan { table: supplier, columns: [s_suppkey, s_name, s_address, s_phone] }
                  BatchHashAgg { group_keys: [$0], aggs: [sum($1)] }
                    BatchProject { exprs: [$0, ($1 * (1:Int32 - $2))] }
                      BatchExchange { order: [], dist: HashShard([0]) }
                        BatchFilter { predicate: ($3 >= '1993-01-01':Varchar::Date) AND ($3 < ('1993-01-01':Varchar::Date + '3 mons 00:00:00':Interval)) }
                          BatchScan { table: lineitem, columns: [l_suppkey, l_extendedprice, l_discount, l_shipdate] }
            BatchExchange { order: [], dist: HashShard([0]) }
              BatchSimpleAgg { aggs: [max($0)] }
                BatchExchange { order: [], dist: Single }
                  BatchProject { exprs: [$1] }
                    BatchHashAgg { group_keys: [$0], aggs: [sum($1)] }
                      BatchProject { exprs: [$0, ($1 * (1:Int32 - $2))] }
                        BatchExchange { order: [], dist: HashShard([0]) }
                          BatchFilter { predicate: ($3 >= '1993-01-01':Varchar::Date) AND ($3 < ('1993-01-01':Varchar::Date + '3 mons 00:00:00':Interval)) }
                            BatchScan { table: lineitem, columns: [l_suppkey, l_extendedprice, l_discount, l_shipdate] }
  stream_plan: |
    StreamMaterialize { columns: [s_suppkey, s_name, s_address, s_phone, total_revenue, _row_id(hidden), l_suppkey(hidden), agg#0(hidden), agg#1(hidden)], pk_columns: [_row_id, l_suppkey, agg#0, agg#1], order_descs: [s_suppkey, _row_id, l_suppkey, agg#0, agg#1] }
      StreamExchange { dist: HashShard([5, 6, 7, 8]) }
        StreamProject { exprs: [$0, $1, $2, $3, $4, $5, $6, $7, $8] }
          StreamHashJoin { type: Inner, predicate: $4 = $8 }
            StreamProject { exprs: [$0, $1, $2, $3, $7, $4, $5] }
              StreamExchange { dist: HashShard([7]) }
                StreamHashJoin { type: Inner, predicate: $0 = $5 }
                  StreamExchange { dist: HashShard([0]) }
                    StreamTableScan { table: supplier, columns: [s_suppkey, s_name, s_address, s_phone, _row_id], pk_indices: [4] }
                  StreamHashAgg { group_keys: [$0], aggs: [count, sum($1)] }
                    StreamProject { exprs: [$0, ($1 * (1:Int32 - $2)), $4] }
                      StreamExchange { dist: HashShard([0]) }
                        StreamFilter { predicate: ($3 >= '1993-01-01':Varchar::Date) AND ($3 < ('1993-01-01':Varchar::Date + '3 mons 00:00:00':Interval)) }
                          StreamTableScan { table: lineitem, columns: [l_suppkey, l_extendedprice, l_discount, l_shipdate, _row_id], pk_indices: [4] }
            StreamExchange { dist: HashShard([1]) }
              StreamSimpleAgg { aggs: [count, max($0)] }
                StreamExchange { dist: Single }
                  StreamProject { exprs: [$2, $0] }
                    StreamHashAgg { group_keys: [$0], aggs: [count, sum($1)] }
                      StreamProject { exprs: [$0, ($1 * (1:Int32 - $2)), $4] }
                        StreamExchange { dist: HashShard([0]) }
                          StreamFilter { predicate: ($3 >= '1993-01-01':Varchar::Date) AND ($3 < ('1993-01-01':Varchar::Date + '3 mons 00:00:00':Interval)) }
                            StreamTableScan { table: lineitem, columns: [l_suppkey, l_extendedprice, l_discount, l_shipdate, _row_id], pk_indices: [4] }
- id: tpch_q16
  before:
    - create_tables
  sql: |
    select
      p_brand,
      p_type,
      p_size,
      count(distinct ps_suppkey) as supplier_cnt
    from
      partsupp,
      part
    where
      p_partkey = ps_partkey
      and p_brand <> 'Brand#45'
      and p_type not like 'SMALL PLATED%'
      and p_size in (19, 17, 16, 23, 10, 4, 38, 11)
      and ps_suppkey not in (
        select
          s_suppkey
        from
          supplier
        where
          s_comment like '%Customer%Complaints%'
      )
    group by
      p_brand,
      p_type,
      p_size
    order by
      supplier_cnt desc,
      p_brand,
      p_type,
      p_size;
  batch_plan: |
    BatchExchange { order: [$3 DESC, $0 ASC, $1 ASC, $2 ASC], dist: Single }
      BatchSort { order: [$3 DESC, $0 ASC, $1 ASC, $2 ASC] }
        BatchHashAgg { group_keys: [$0, $1, $2], aggs: [count($3)] }
          BatchProject { exprs: [$1, $2, $3, $0] }
            BatchExchange { order: [], dist: HashShard([1, 2, 3]) }
              BatchHashJoin { type: LeftAnti, predicate: $0 = $4 }
                BatchProject { exprs: [$1, $3, $4, $5] }
                  BatchExchange { order: [], dist: HashShard([1]) }
                    BatchHashJoin { type: Inner, predicate: $0 = $2 }
                      BatchExchange { order: [], dist: HashShard([0]) }
                        BatchScan { table: partsupp, columns: [ps_partkey, ps_suppkey] }
                      BatchExchange { order: [], dist: HashShard([0]) }
                        BatchFilter { predicate: ($1 <> 'Brand#45':Varchar) AND Not(Like($2, 'SMALL PLATED%':Varchar)) AND In($3, 19:Int32, 17:Int32, 16:Int32, 23:Int32, 10:Int32, 4:Int32, 38:Int32, 11:Int32) }
                          BatchScan { table: part, columns: [p_partkey, p_brand, p_type, p_size] }
                BatchProject { exprs: [$0] }
                  BatchExchange { order: [], dist: HashShard([0]) }
                    BatchFilter { predicate: Like($1, '%Customer%Complaints%':Varchar) }
                      BatchScan { table: supplier, columns: [s_suppkey, s_comment] }
  stream_plan: |
    StreamMaterialize { columns: [p_brand, p_type, p_size, agg#0(hidden), supplier_cnt], pk_columns: [p_brand, p_type, p_size], order_descs: [supplier_cnt, p_brand, p_type, p_size] }
      StreamHashAgg { group_keys: [$0, $1, $2], aggs: [count, count($3)] }
        StreamProject { exprs: [$1, $2, $3, $0, $4, $5] }
          StreamExchange { dist: HashShard([1, 2, 3]) }
            StreamHashJoin { type: LeftAnti, predicate: $0 = $6 }
              StreamProject { exprs: [$1, $4, $5, $6, $2, $7] }
                StreamExchange { dist: HashShard([1]) }
                  StreamHashJoin { type: Inner, predicate: $0 = $3 }
                    StreamExchange { dist: HashShard([0]) }
                      StreamTableScan { table: partsupp, columns: [ps_partkey, ps_suppkey, _row_id], pk_indices: [2] }
                    StreamExchange { dist: HashShard([0]) }
                      StreamFilter { predicate: ($1 <> 'Brand#45':Varchar) AND Not(Like($2, 'SMALL PLATED%':Varchar)) AND In($3, 19:Int32, 17:Int32, 16:Int32, 23:Int32, 10:Int32, 4:Int32, 38:Int32, 11:Int32) }
                        StreamTableScan { table: part, columns: [p_partkey, p_brand, p_type, p_size, _row_id], pk_indices: [4] }
              StreamProject { exprs: [$0, $2] }
                StreamExchange { dist: HashShard([0]) }
                  StreamFilter { predicate: Like($1, '%Customer%Complaints%':Varchar) }
                    StreamTableScan { table: supplier, columns: [s_suppkey, s_comment, _row_id], pk_indices: [2] }
- id: tpch_q17
  before:
    - create_tables
  sql: |
    select
      ROUND(sum(l_extendedprice) / 7.0, 16) as avg_yearly
    from
      lineitem,
      part
    where
      p_partkey = l_partkey
      and p_brand = 'Brand#13'
      and p_container = 'JUMBO PKG'
      and l_quantity < (
        select
          0.2 * avg(l_quantity)
        from
          lineitem
        where
          l_partkey = p_partkey
      );
  batch_plan: |
    BatchProject { exprs: [RoundDigit(($0 / 7.0:Decimal), 16:Int32)] }
      BatchSimpleAgg { aggs: [sum($0)] }
        BatchExchange { order: [], dist: Single }
          BatchProject { exprs: [$1] }
            BatchFilter { predicate: ($0 < (0.2:Decimal * ($2 / $3))) }
              BatchProject { exprs: [$5, $6, $27, $28] }
                BatchHashAgg { group_keys: [$0, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26], aggs: [sum($27), count($27)] }
                  BatchProject { exprs: [$0, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27] }
                    BatchHashJoin { type: LeftOuter, predicate: $18 = $28 }
                      BatchExchange { order: [], dist: HashShard([18]) }
                        BatchHashJoin { type: Inner, predicate: $2 = $18 }
                          BatchExchange { order: [], dist: HashShard([2]) }
                            BatchScan { table: lineitem, columns: [_row_id, l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment] }
                          BatchExchange { order: [], dist: HashShard([1]) }
                            BatchFilter { predicate: ($4 = 'Brand#13':Varchar) AND ($7 = 'JUMBO PKG':Varchar) }
                              BatchScan { table: part, columns: [_row_id, p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment] }
                      BatchProject { exprs: [$1, $0] }
                        BatchExchange { order: [], dist: HashShard([0]) }
                          BatchScan { table: lineitem, columns: [l_partkey, l_quantity] }
  stream_plan: |
    StreamMaterialize { columns: [avg_yearly, agg#0(hidden), agg#1(hidden)], pk_columns: [agg#0, agg#1] }
      StreamProject { exprs: [RoundDigit(($1 / 7.0:Decimal), 16:Int32), $0, $1] }
        StreamSimpleAgg { aggs: [count, sum($0)] }
          StreamExchange { dist: Single }
            StreamProject { exprs: [$1, $4, $5, $6, $7, $8, $0, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28] }
              StreamFilter { predicate: ($0 < (0.2:Decimal * ($2 / $3))) }
                StreamProject { exprs: [$5, $6, $28, $29, $0, $1, $2, $3, $4, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26] }
                  StreamHashAgg { group_keys: [$0, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26], aggs: [count, sum($27), count($27)] }
                    StreamProject { exprs: [$0, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $29] }
                      StreamHashJoin { type: LeftOuter, predicate: $18 = $28 }
                        StreamExchange { dist: HashShard([18]) }
                          StreamHashJoin { type: Inner, predicate: $2 = $18 }
                            StreamExchange { dist: HashShard([2]) }
                              StreamTableScan { table: lineitem, columns: [_row_id, l_orderkey, l_partkey, l_suppkey, l_linenumber, l_quantity, l_extendedprice, l_discount, l_tax, l_returnflag, l_linestatus, l_shipdate, l_commitdate, l_receiptdate, l_shipinstruct, l_shipmode, l_comment], pk_indices: [0] }
                            StreamExchange { dist: HashShard([1]) }
                              StreamFilter { predicate: ($4 = 'Brand#13':Varchar) AND ($7 = 'JUMBO PKG':Varchar) }
                                StreamTableScan { table: part, columns: [_row_id, p_partkey, p_name, p_mfgr, p_brand, p_type, p_size, p_container, p_retailprice, p_comment], pk_indices: [0] }
                        StreamProject { exprs: [$1, $0, $2] }
                          StreamExchange { dist: HashShard([0]) }
                            StreamTableScan { table: lineitem, columns: [l_partkey, l_quantity, _row_id], pk_indices: [2] }
- id: tpch_q18
  before:
    - create_tables
  sql: |
    select
      c_name,
      c_custkey,
      o_orderkey,
      o_orderdate,
      o_totalprice,
      sum(l_quantity) quantity
    from
      customer,
      orders,
      lineitem
    where
      o_orderkey in (
        select
          l_orderkey
        from
          lineitem
        group by
          l_orderkey
        having
          sum(l_quantity) > 1
      )
      and c_custkey = o_custkey
      and o_orderkey = l_orderkey
    group by
      c_name,
      c_custkey,
      o_orderkey,
      o_orderdate,
      o_totalprice
    order by
      o_totalprice desc,
      o_orderdate
    LIMIT 100;
  batch_plan: |
    BatchTopN { order: [$4 DESC, $3 ASC], limit: 100, offset: 0 }
      BatchExchange { order: [], dist: Single }
        BatchHashAgg { group_keys: [$0, $1, $2, $3, $4], aggs: [sum($5)] }
          BatchProject { exprs: [$1, $0, $2, $4, $3, $5] }
            BatchHashJoin { type: LeftSemi, predicate: $2 = $6 }
              BatchProject { exprs: [$0, $1, $2, $3, $4, $6] }
                BatchHashJoin { type: Inner, predicate: $2 = $5 }
                  BatchProject { exprs: [$0, $1, $2, $4, $5] }
                    BatchExchange { order: [], dist: HashShard([2]) }
                      BatchHashJoin { type: Inner, predicate: $0 = $3 }
                        BatchExchange { order: [], dist: HashShard([0]) }
                          BatchScan { table: customer, columns: [c_custkey, c_name] }
                        BatchExchange { order: [], dist: HashShard([1]) }
                          BatchScan { table: orders, columns: [o_orderkey, o_custkey, o_totalprice, o_orderdate] }
                  BatchExchange { order: [], dist: HashShard([0]) }
                    BatchScan { table: lineitem, columns: [l_orderkey, l_quantity] }
              BatchProject { exprs: [$0] }
                BatchFilter { predicate: ($1 > 1:Int32) }
                  BatchHashAgg { group_keys: [$0], aggs: [sum($1)] }
                    BatchExchange { order: [], dist: HashShard([0]) }
                      BatchScan { table: lineitem, columns: [l_orderkey, l_quantity] }
  stream_plan: |
    StreamMaterialize { columns: [c_name, c_custkey, o_orderkey, o_orderdate, o_totalprice, agg#0(hidden), quantity], pk_columns: [c_name, c_custkey, o_orderkey, o_orderdate, o_totalprice], order_descs: [o_totalprice, o_orderdate, c_name, c_custkey, o_orderkey] }
      StreamTopN { order: [$4 DESC, $3 ASC], limit: 100, offset: 0 }
        StreamExchange { dist: Single }
          StreamHashAgg { group_keys: [$0, $1, $2, $3, $4], aggs: [count, sum($5)] }
            StreamProject { exprs: [$1, $0, $2, $4, $3, $5, $6, $7, $8] }
              StreamHashJoin { type: LeftSemi, predicate: $2 = $9 }
                StreamProject { exprs: [$0, $1, $2, $3, $4, $8, $5, $6, $9] }
                  StreamHashJoin { type: Inner, predicate: $2 = $7 }
                    StreamProject { exprs: [$0, $1, $3, $5, $6, $2, $7] }
                      StreamExchange { dist: HashShard([3]) }
                        StreamHashJoin { type: Inner, predicate: $0 = $4 }
                          StreamExchange { dist: HashShard([0]) }
                            StreamTableScan { table: customer, columns: [c_custkey, c_name, _row_id], pk_indices: [2] }
                          StreamExchange { dist: HashShard([1]) }
                            StreamTableScan { table: orders, columns: [o_orderkey, o_custkey, o_totalprice, o_orderdate, _row_id], pk_indices: [4] }
                    StreamExchange { dist: HashShard([0]) }
                      StreamTableScan { table: lineitem, columns: [l_orderkey, l_quantity, _row_id], pk_indices: [2] }
                StreamProject { exprs: [$0] }
                  StreamFilter { predicate: ($2 > 1:Int32) }
                    StreamHashAgg { group_keys: [$0], aggs: [count, sum($1)] }
                      StreamExchange { dist: HashShard([0]) }
                        StreamTableScan { table: lineitem, columns: [l_orderkey, l_quantity, _row_id], pk_indices: [2] }
- id: tpch_q19
  before:
    - create_tables
  sql: |
    select
      sum(l_extendedprice* (1 - l_discount)) as revenue
    from
      lineitem,
      part
    where
      (
        p_partkey = l_partkey
        and p_brand = 'Brand#52'
        and p_container in ('SM CASE', 'SM BOX', 'SM PACK', 'SM PKG')
        and l_quantity >= 1 and l_quantity <= 11
        and p_size between 1 and 5
        and l_shipmode in ('AIR', 'AIR REG')
        and l_shipinstruct = 'DELIVER IN PERSON'
      )
      or
      (
        p_partkey = l_partkey
        and p_brand = 'Brand#24'
        and p_container in ('MED BAG', 'MED BOX', 'MED PKG', 'MED PACK')
        and l_quantity >= 30 and l_quantity <= 40
        and p_size between 1 and 10
        and l_shipmode in ('AIR', 'AIR REG')
        and l_shipinstruct = 'DELIVER IN PERSON'
      )
      or
      (
        p_partkey = l_partkey
        and p_brand = 'Brand#32'
        and p_container in ('LG CASE', 'LG BOX', 'LG PACK', 'LG PKG')
        and l_quantity >= 10 and l_quantity <= 20
        and p_size between 1 and 15
        and l_shipmode in ('AIR', 'AIR REG')
        and l_shipinstruct = 'DELIVER IN PERSON'
      );
  batch_plan: |
    BatchSimpleAgg { aggs: [sum($0)] }
      BatchExchange { order: [], dist: Single }
        BatchProject { exprs: [($2 * (1:Int32 - $3))] }
          BatchFilter { predicate: ((((((($5 = 'Brand#52':Varchar) AND In($7, 'SM CASE':Varchar, 'SM BOX':Varchar, 'SM PACK':Varchar, 'SM PKG':Varchar)) AND ($1 >= 1:Int32)) AND ($1 <= 11:Int32)) AND ($6 <= 5:Int32)) OR ((((($5 = 'Brand#24':Varchar) AND In($7, 'MED BAG':Varchar, 'MED BOX':Varchar, 'MED PKG':Varchar, 'MED PACK':Varchar)) AND ($1 >= 30:Int32)) AND ($1 <= 40:Int32)) AND ($6 <= 10:Int32))) OR ((((($5 = 'Brand#32':Varchar) AND In($7, 'LG CASE':Varchar, 'LG BOX':Varchar, 'LG PACK':Varchar, 'LG PKG':Varchar)) AND ($1 >= 10:Int32)) AND ($1 <= 20:Int32)) AND ($6 <= 15:Int32))) }
            BatchHashJoin { type: Inner, predicate: $0 = $4 }
              BatchProject { exprs: [$0, $1, $2, $3] }
                BatchExchange { order: [], dist: HashShard([0]) }
                  BatchFilter { predicate: In($5, 'AIR':Varchar, 'AIR REG':Varchar) AND ($4 = 'DELIVER IN PERSON':Varchar) }
                    BatchScan { table: lineitem, columns: [l_partkey, l_quantity, l_extendedprice, l_discount, l_shipinstruct, l_shipmode] }
              BatchExchange { order: [], dist: HashShard([0]) }
                BatchFilter { predicate: ($2 >= 1:Int32) }
                  BatchScan { table: part, columns: [p_partkey, p_brand, p_size, p_container] }
  stream_plan: |
    StreamMaterialize { columns: [agg#0(hidden), revenue], pk_columns: [agg#0, revenue] }
      StreamSimpleAgg { aggs: [count, sum($0)] }
        StreamExchange { dist: Single }
          StreamProject { exprs: [($2 * (1:Int32 - $3)), $4, $9] }
            StreamFilter { predicate: ((((((($6 = 'Brand#52':Varchar) AND In($8, 'SM CASE':Varchar, 'SM BOX':Varchar, 'SM PACK':Varchar, 'SM PKG':Varchar)) AND ($1 >= 1:Int32)) AND ($1 <= 11:Int32)) AND ($7 <= 5:Int32)) OR ((((($6 = 'Brand#24':Varchar) AND In($8, 'MED BAG':Varchar, 'MED BOX':Varchar, 'MED PKG':Varchar, 'MED PACK':Varchar)) AND ($1 >= 30:Int32)) AND ($1 <= 40:Int32)) AND ($7 <= 10:Int32))) OR ((((($6 = 'Brand#32':Varchar) AND In($8, 'LG CASE':Varchar, 'LG BOX':Varchar, 'LG PACK':Varchar, 'LG PKG':Varchar)) AND ($1 >= 10:Int32)) AND ($1 <= 20:Int32)) AND ($7 <= 15:Int32))) }
              StreamHashJoin { type: Inner, predicate: $0 = $5 }
                StreamProject { exprs: [$0, $1, $2, $3, $6] }
                  StreamExchange { dist: HashShard([0]) }
                    StreamFilter { predicate: In($5, 'AIR':Varchar, 'AIR REG':Varchar) AND ($4 = 'DELIVER IN PERSON':Varchar) }
                      StreamTableScan { table: lineitem, columns: [l_partkey, l_quantity, l_extendedprice, l_discount, l_shipinstruct, l_shipmode, _row_id], pk_indices: [6] }
                StreamExchange { dist: HashShard([0]) }
                  StreamFilter { predicate: ($2 >= 1:Int32) }
                    StreamTableScan { table: part, columns: [p_partkey, p_brand, p_size, p_container, _row_id], pk_indices: [4] }
- id: tpch_q20
  before:
    - create_tables
  sql: |
    select
      s_name,
      s_address
    from
      supplier,
      nation
    where
      s_suppkey in (
        select
          ps_suppkey
        from
          partsupp
        where
          ps_partkey in (
            select
              p_partkey
            from
              part
            where
              p_name like 'forest%'
          )
          and ps_availqty > (
            select
              0.5 * sum(l_quantity)
            from
              lineitem
            where
              l_partkey = ps_partkey
              and l_suppkey = ps_suppkey
              and l_shipdate >= date '1994-01-01'
              and l_shipdate < date '1994-01-01' + interval '1' year
          )
      )
      and s_nationkey = n_nationkey
      and n_name = 'KENYA'
    order by
      s_name;
  batch_plan: |
    BatchExchange { order: [$0 ASC], dist: Single }
      BatchSort { order: [$0 ASC] }
        BatchProject { exprs: [$1, $2] }
          BatchHashJoin { type: LeftSemi, predicate: $0 = $3 }
            BatchProject { exprs: [$0, $1, $2] }
              BatchExchange { order: [], dist: HashShard([0]) }
                BatchHashJoin { type: Inner, predicate: $3 = $4 }
                  BatchExchange { order: [], dist: HashShard([3]) }
                    BatchScan { table: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey] }
                  BatchProject { exprs: [$0] }
                    BatchExchange { order: [], dist: HashShard([0]) }
                      BatchFilter { predicate: ($1 = 'KENYA':Varchar) }
                        BatchScan { table: nation, columns: [n_nationkey, n_name] }
            BatchProject { exprs: [$0] }
              BatchExchange { order: [], dist: HashShard([0]) }
                BatchFilter { predicate: ($1 > (0.5:Decimal * $2)) }
                  BatchProject { exprs: [$2, $3, $6] }
                    BatchHashAgg { group_keys: [$0, $1, $2, $3, $4, $5], aggs: [sum($6)] }
                      BatchProject { exprs: [$0, $1, $2, $3, $4, $5, $6] }
                        BatchHashJoin { type: LeftOuter, predicate: $1 = $7 AND $2 = $8 }
                          BatchExchange { order: [], dist: HashShard([1, 2]) }
                            BatchHashJoin { type: LeftSemi, predicate: $1 = $6 }
                              BatchExchange { order: [], dist: HashShard([1]) }
                                BatchScan { table: partsupp, columns: [_row_id, ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment] }
                              BatchProject { exprs: [$0] }
                                BatchExchange { order: [], dist: HashShard([0]) }
                                  BatchFilter { predicate: Like($1, 'forest%':Varchar) }
                                    BatchScan { table: part, columns: [p_partkey, p_name] }
                          BatchProject { exprs: [$2, $0, $1] }
                            BatchExchange { order: [], dist: HashShard([0, 1]) }
                              BatchFilter { predicate: ($3 >= '1994-01-01':Varchar::Date) AND ($3 < ('1994-01-01':Varchar::Date + '1 year 00:00:00':Interval)) }
                                BatchScan { table: lineitem, columns: [l_partkey, l_suppkey, l_quantity, l_shipdate] }
  stream_plan: |
    StreamMaterialize { columns: [s_name, s_address, _row_id(hidden), _row_id#1(hidden)], pk_columns: [_row_id, _row_id#1], order_descs: [s_name, _row_id, _row_id#1] }
      StreamExchange { dist: HashShard([2, 3]) }
        StreamProject { exprs: [$1, $2, $3, $4] }
          StreamHashJoin { type: LeftSemi, predicate: $0 = $5 }
            StreamProject { exprs: [$0, $1, $2, $4, $6] }
              StreamExchange { dist: HashShard([0]) }
                StreamHashJoin { type: Inner, predicate: $3 = $5 }
                  StreamExchange { dist: HashShard([3]) }
                    StreamTableScan { table: supplier, columns: [s_suppkey, s_name, s_address, s_nationkey, _row_id], pk_indices: [4] }
                  StreamProject { exprs: [$0, $2] }
                    StreamExchange { dist: HashShard([0]) }
                      StreamFilter { predicate: ($1 = 'KENYA':Varchar) }
                        StreamTableScan { table: nation, columns: [n_nationkey, n_name, _row_id], pk_indices: [2] }
            StreamProject { exprs: [$0, $3, $4, $1, $5, $6] }
              StreamExchange { dist: HashShard([0]) }
                StreamFilter { predicate: ($1 > (0.5:Decimal * $2)) }
                  StreamProject { exprs: [$2, $3, $7, $0, $1, $4, $5] }
                    StreamHashAgg { group_keys: [$0, $1, $2, $3, $4, $5], aggs: [count, sum($6)] }
                      StreamProject { exprs: [$0, $1, $2, $3, $4, $5, $6, $9] }
                        StreamHashJoin { type: LeftOuter, predicate: $1 = $7 AND $2 = $8 }
                          StreamExchange { dist: HashShard([1, 2]) }
                            StreamHashJoin { type: LeftSemi, predicate: $1 = $6 }
                              StreamExchange { dist: HashShard([1]) }
                                StreamTableScan { table: partsupp, columns: [_row_id, ps_partkey, ps_suppkey, ps_availqty, ps_supplycost, ps_comment], pk_indices: [0] }
                              StreamProject { exprs: [$0, $2] }
                                StreamExchange { dist: HashShard([0]) }
                                  StreamFilter { predicate: Like($1, 'forest%':Varchar) }
                                    StreamTableScan { table: part, columns: [p_partkey, p_name, _row_id], pk_indices: [2] }
                          StreamProject { exprs: [$2, $0, $1, $4] }
                            StreamExchange { dist: HashShard([0, 1]) }
                              StreamFilter { predicate: ($3 >= '1994-01-01':Varchar::Date) AND ($3 < ('1994-01-01':Varchar::Date + '1 year 00:00:00':Interval)) }
                                StreamTableScan { table: lineitem, columns: [l_partkey, l_suppkey, l_quantity, l_shipdate, _row_id], pk_indices: [4] }
- id: tpch_q21
  before:
    - create_tables
  sql: |
    select
      s_name,
      count(*) as numwait
    from
      supplier,
      lineitem l1,
      orders,
      nation
    where
      s_suppkey = l1.l_suppkey
      and o_orderkey = l1.l_orderkey
      and o_orderstatus = 'F'
      and l1.l_receiptdate > l1.l_commitdate
      and exists (
        select
          *
        from
          lineitem l2
        where
          l2.l_orderkey = l1.l_orderkey
          and l2.l_suppkey <> l1.l_suppkey
      )
      and not exists (
        select
          *
        from
          lineitem l3
        where
          l3.l_orderkey = l1.l_orderkey
          and l3.l_suppkey <> l1.l_suppkey
          and l3.l_receiptdate > l3.l_commitdate
      )
      and s_nationkey = n_nationkey
      and n_name = 'GERMANY'
    group by
      s_name
    order by
      numwait desc,
      s_name
    LIMIT 100;
  batch_plan: |
    BatchTopN { order: [$1 DESC, $0 ASC], limit: 100, offset: 0 }
      BatchExchange { order: [], dist: Single }
        BatchHashAgg { group_keys: [$0], aggs: [count] }
          BatchProject { exprs: [$0] }
            BatchExchange { order: [], dist: HashShard([0]) }
              BatchHashJoin { type: LeftAnti, predicate: $1 = $3 AND ($4 <> $2) }
                BatchHashJoin { type: LeftSemi, predicate: $1 = $3 AND ($4 <> $2) }
                  BatchProject { exprs: [$0, $1, $2] }
                    BatchHashJoin { type: Inner, predicate: $1 = $3 }
                      BatchProject { exprs: [$0, $2, $3] }
                        BatchExchange { order: [], dist: HashShard([2]) }
                          BatchHashJoin { type: Inner, predicate: $1 = $4 }
                            BatchProject { exprs: [$1, $2, $3, $4] }
                              BatchExchange { order: [], dist: HashShard([2]) }
                                BatchHashJoin { type: Inner, predicate: $0 = $4 }
                                  BatchExchange { order: [], dist: HashShard([0]) }
                                    BatchScan { table: supplier, columns: [s_suppkey, s_name, s_nationkey] }
                                  BatchProject { exprs: [$0, $1] }
                                    BatchExchange { order: [], dist: HashShard([1]) }
                                      BatchFilter { predicate: ($3 > $2) }
                                        BatchScan { table: lineitem, columns: [l_orderkey, l_suppkey, l_commitdate, l_receiptdate] }
                            BatchProject { exprs: [$0] }
                              BatchExchange { order: [], dist: HashShard([0]) }
                                BatchFilter { predicate: ($1 = 'GERMANY':Varchar) }
                                  BatchScan { table: nation, columns: [n_nationkey, n_name] }
                      BatchProject { exprs: [$0] }
                        BatchExchange { order: [], dist: HashShard([0]) }
                          BatchFilter { predicate: ($1 = 'F':Varchar) }
                            BatchScan { table: orders, columns: [o_orderkey, o_orderstatus] }
                  BatchExchange { order: [], dist: HashShard([0]) }
                    BatchScan { table: lineitem, columns: [l_orderkey, l_suppkey] }
                BatchProject { exprs: [$0, $1] }
                  BatchExchange { order: [], dist: HashShard([0]) }
                    BatchFilter { predicate: ($3 > $2) }
                      BatchScan { table: lineitem, columns: [l_orderkey, l_suppkey, l_commitdate, l_receiptdate] }
  stream_plan: |
    StreamMaterialize { columns: [s_name, agg#0(hidden), numwait], pk_columns: [s_name], order_descs: [numwait, s_name] }
      StreamTopN { order: [$2 DESC, $0 ASC], limit: 100, offset: 0 }
        StreamExchange { dist: Single }
          StreamHashAgg { group_keys: [$0], aggs: [count, count] }
            StreamProject { exprs: [$0, $3, $4, $5, $6] }
              StreamExchange { dist: HashShard([0]) }
                StreamHashJoin { type: LeftAnti, predicate: $1 = $7 AND ($8 <> $2) }
                  StreamHashJoin { type: LeftSemi, predicate: $1 = $7 AND ($8 <> $2) }
                    StreamProject { exprs: [$0, $1, $2, $3, $4, $5, $7] }
                      StreamHashJoin { type: Inner, predicate: $1 = $6 }
                        StreamProject { exprs: [$0, $2, $3, $4, $5, $7] }
                          StreamExchange { dist: HashShard([2]) }
                            StreamHashJoin { type: Inner, predicate: $1 = $6 }
                              StreamProject { exprs: [$1, $2, $4, $5, $3, $6] }
                                StreamExchange { dist: HashShard([2]) }
                                  StreamHashJoin { type: Inner, predicate: $0 = $5 }
                                    StreamExchange { dist: HashShard([0]) }
                                      StreamTableScan { table: supplier, columns: [s_suppkey, s_name, s_nationkey, _row_id], pk_indices: [3] }
                                    StreamProject { exprs: [$0, $1, $4] }
                                      StreamExchange { dist: HashShard([1]) }
                                        StreamFilter { predicate: ($3 > $2) }
                                          StreamTableScan { table: lineitem, columns: [l_orderkey, l_suppkey, l_commitdate, l_receiptdate, _row_id], pk_indices: [4] }
                              StreamProject { exprs: [$0, $2] }
                                StreamExchange { dist: HashShard([0]) }
                                  StreamFilter { predicate: ($1 = 'GERMANY':Varchar) }
                                    StreamTableScan { table: nation, columns: [n_nationkey, n_name, _row_id], pk_indices: [2] }
                        StreamProject { exprs: [$0, $2] }
                          StreamExchange { dist: HashShard([0]) }
                            StreamFilter { predicate: ($1 = 'F':Varchar) }
                              StreamTableScan { table: orders, columns: [o_orderkey, o_orderstatus, _row_id], pk_indices: [2] }
                    StreamExchange { dist: HashShard([0]) }
                      StreamTableScan { table: lineitem, columns: [l_orderkey, l_suppkey, _row_id], pk_indices: [2] }
                  StreamProject { exprs: [$0, $1, $4] }
                    StreamExchange { dist: HashShard([0]) }
                      StreamFilter { predicate: ($3 > $2) }
                        StreamTableScan { table: lineitem, columns: [l_orderkey, l_suppkey, l_commitdate, l_receiptdate, _row_id], pk_indices: [4] }
- id: tpch_q22
  before:
    - create_tables
  sql: |
    select
      cntrycode,
      count(*) as numcust,
      sum(c_acctbal) as totacctbal
    from
      (
        select
          substring(c_phone from 1 for 2) as cntrycode,
          c_acctbal
        from
          customer
        where
          substring(c_phone from 1 for 2) in
            ('30', '24', '31', '38', '25', '34', '37')
          and c_acctbal > (
            select
              avg(c_acctbal)
            from
              customer
            where
              c_acctbal > 0.00::numeric
              and substring(c_phone from 1 for 2) in
                ('30', '24', '31', '38', '25', '34', '37')
          )
          and not exists (
            select
              *
            from
              orders
            where
              o_custkey = c_custkey
          )
      ) as custsale
    group by
      cntrycode
    order by
      cntrycode;
  batch_plan: |
    BatchExchange { order: [$0 ASC], dist: Single }
      BatchSort { order: [$0 ASC] }
        BatchHashAgg { group_keys: [$0], aggs: [count, sum($1)] }
          BatchExchange { order: [], dist: HashShard([0]) }
            BatchProject { exprs: [Substr($0, 1:Int32, 2:Int32), $1] }
              BatchExchange { order: [], dist: AnyShard }
                BatchNestedLoopJoin { type: Inner, predicate: ($1 > $2) }
                  BatchExchange { order: [], dist: Single }
                    BatchProject { exprs: [$1, $2] }
                      BatchHashJoin { type: LeftAnti, predicate: $0 = $3 }
                        BatchExchange { order: [], dist: HashShard([0]) }
                          BatchFilter { predicate: In(Substr($1, 1:Int32, 2:Int32), '30':Varchar, '24':Varchar, '31':Varchar, '38':Varchar, '25':Varchar, '34':Varchar, '37':Varchar) }
                            BatchScan { table: customer, columns: [c_custkey, c_phone, c_acctbal] }
                        BatchExchange { order: [], dist: HashShard([0]) }
                          BatchScan { table: orders, columns: [o_custkey] }
                  BatchProject { exprs: [($0 / $1)] }
                    BatchSimpleAgg { aggs: [sum($0), count($0)] }
                      BatchExchange { order: [], dist: Single }
                        BatchProject { exprs: [$1] }
                          BatchFilter { predicate: ($1 > 0.00:Decimal) AND In(Substr($0, 1:Int32, 2:Int32), '30':Varchar, '24':Varchar, '31':Varchar, '38':Varchar, '25':Varchar, '34':Varchar, '37':Varchar) }
                            BatchScan { table: customer, columns: [c_phone, c_acctbal] }
