# This file is automatically generated. See `src/frontend/test_runner/README.md` for more information.
- sql: values (11, 22), (33+(1+2), 44);
  batch_plan: |
    BatchValues { rows: [[11:Int32, 22:Int32], [(33:Int32 + (1:Int32 + 2:Int32)), 44:Int32]] }
- sql: select * from t
  binder_error: 'Catalog error: table or source not found: t'
- sql: |
    create table t (v1 bigint, v2 double precision);
    select * from t;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchScan { table: t, columns: [v1, v2] }
  stream_plan: |
    StreamMaterialize { columns: [v1, v2, _row_id(hidden)], pk_columns: [_row_id] }
      StreamTableScan { table: t, columns: [v1, v2, _row_id], pk_indices: [2] }
- sql: |
    create table t (v1 bigint, v2 double precision);
    select t2.* from t;
  binder_error: 'Item not found: relation "t2"'
- sql: |
    create table t ();
    select * from t where 1>2 and 1=1 and 3<1 and 4<>1 or 1=1 and 2>=1 and 1<=2;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchFilter { predicate: (1:Int32 = 1:Int32) AND ((((1:Int32 > 2:Int32) AND (3:Int32 < 1:Int32)) AND (4:Int32 <> 1:Int32)) OR ((2:Int32 >= 1:Int32) AND (1:Int32 <= 2:Int32))) }
        BatchScan { table: t, columns: [] }
  stream_plan: |
    StreamMaterialize { columns: [_row_id(hidden)], pk_columns: [_row_id] }
      StreamFilter { predicate: (1:Int32 = 1:Int32) AND ((((1:Int32 > 2:Int32) AND (3:Int32 < 1:Int32)) AND (4:Int32 <> 1:Int32)) OR ((2:Int32 >= 1:Int32) AND (1:Int32 <= 2:Int32))) }
        StreamTableScan { table: t, columns: [_row_id], pk_indices: [0] }
- sql: |
    create table t (v1 int);
    select * from t where v1<1;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchFilter { predicate: ($0 < 1:Int32) }
        BatchScan { table: t, columns: [v1] }
  stream_plan: |
    StreamMaterialize { columns: [v1, _row_id(hidden)], pk_columns: [_row_id] }
      StreamFilter { predicate: ($0 < 1:Int32) }
        StreamTableScan { table: t, columns: [v1, _row_id], pk_indices: [1] }
- sql: |
    /* test boolean expression common factor extraction */
    create table t (v1 Boolean, v2 Boolean, v3 Boolean);
    select * from t where v1 AND v2 AND ((v1 AND v2) OR (v2 AND v3));
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchFilter { predicate: $0 AND $1 AND ($0 OR $2) }
        BatchScan { table: t, columns: [v1, v2, v3] }
- sql: |
    /* test boolean expression simplification */
    create table t (v1 Boolean, v2 Boolean, v3 Boolean);
    select * from t where v1 AND NOT(v1 OR v2 Or NOT(v1 AND v2 AND true));
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchFilter { predicate: $0 AND Not($0) AND Not($1) AND $1 }
        BatchScan { table: t, columns: [v1, v2, v3] }
- sql: |
    /* test boolean expression simplification */
    create table t (v1 Boolean, v2 Boolean);
    select * from t where (v1 AND v2) OR (v1 AND v2);
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchFilter { predicate: $0 AND $1 }
        BatchScan { table: t, columns: [v1, v2] }
- sql: |
    /* constant folding for IS TRUE, IS FALSE, IS NULL*/
    create table t(a Boolean);
    select * from t where (NULL IS NULL) IS TRUE AND FALSE IS FALSE AND a;
  logical_plan: |
    LogicalProject { exprs: [$1] }
      LogicalFilter { predicate: $1 }
        LogicalScan { table: t, columns: [_row_id, a] }
- sql: |
    /* constant folding for IS NOT TRUE, IS NOT FALSE */
    create table t(a Boolean);
    select * from t where (NULL IS NOT TRUE) IS NOT FALSE AND a IS NOT TRUE;
  logical_plan: |
    LogicalProject { exprs: [$1] }
      LogicalFilter { predicate: IsNotTrue($1) }
        LogicalScan { table: t, columns: [_row_id, a] }
- sql: |
    /* constant folding IS NOT NULL */
    create table t(a double precision);
    select * from t where (a IS NOT NULL AND 3.14 IS NOT NULL) OR (NULL IS NOT NULL);
  logical_plan: |
    LogicalProject { exprs: [$1] }
      LogicalFilter { predicate: IsNotNull($1) }
        LogicalScan { table: t, columns: [_row_id, a] }
- sql: |
    create table t (v1 int, v2 int);
    select v1 from t;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchScan { table: t, columns: [v1] }
  stream_plan: |
    StreamMaterialize { columns: [v1, _row_id(hidden)], pk_columns: [_row_id] }
      StreamTableScan { table: t, columns: [v1, _row_id], pk_indices: [1] }
- sql: select 1
  batch_plan: |
    BatchProject { exprs: [1:Int32] }
      BatchValues { rows: [[]] }
- sql: |
    create table t (v1 bigint, v2 double precision);
    select a from t as t2(a);
  batch_plan: |
    BatchExchange { order: [], dist: Single }
      BatchScan { table: t, columns: [v1] }
- sql: |
    create table t (v1 int, v2 int);
    delete from t;
  batch_plan: |
    BatchDelete { table: t }
      BatchScan { table: t, columns: [_row_id, v1, v2] }
- sql: |
    create table t (v1 int, v2 int);
    delete from t where v1 = 1;
  batch_plan: |
    BatchDelete { table: t }
      BatchFilter { predicate: ($1 = 1:Int32) }
        BatchScan { table: t, columns: [_row_id, v1, v2] }
- sql: |
    select * from generate_series('2'::INT,'10'::INT,'2'::INT);
  batch_plan: |
    BatchTableFunction { start: '2':Varchar::Int32 stop: '10':Varchar::Int32 step: '2':Varchar::Int32 }
- sql: |
    select * from unnest(Array[1,2,3]);
  batch_plan: |
    BatchTableFunction { [1:Int32, 2:Int32, 3:Int32] }
