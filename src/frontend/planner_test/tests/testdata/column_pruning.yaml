# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- sql: |
    create table t (v1 bigint, v2 double precision);
    select v1 from t
  logical_plan: |
    LogicalProject { exprs: [t.v1] }
    └─LogicalScan { table: t, columns: [t.v1, t.v2, t._row_id] }
  optimized_logical_plan: |
    LogicalScan { table: t, columns: [t.v1] }
- name: filter
  sql: |
    create table t (v1 bigint, v2 double precision, v3 int);
    select v1 from t where v2 > 2
  logical_plan: |
    LogicalProject { exprs: [t.v1] }
    └─LogicalFilter { predicate: (t.v2 > 2:Int32) }
      └─LogicalScan { table: t, columns: [t.v1, t.v2, t.v3, t._row_id] }
  optimized_logical_plan: |
    LogicalScan { table: t, output_columns: [t.v1], required_columns: [v1, v2], predicate: (t.v2 > 2:Int32) }
- name: join
  sql: |
    create table t1 (v1 int, v2 int, v3 int);
    create table t2 (v1 int, v2 int, v3 int);
    select t1.v1, t2.v1 from t1 join t2 on t1.v2 = t2.v2;
  logical_plan: |
    LogicalProject { exprs: [t1.v1, t2.v1] }
    └─LogicalJoin { type: Inner, on: (t1.v2 = t2.v2), output: all }
      ├─LogicalScan { table: t1, columns: [t1.v1, t1.v2, t1.v3, t1._row_id] }
      └─LogicalScan { table: t2, columns: [t2.v1, t2.v2, t2.v3, t2._row_id] }
  optimized_logical_plan: |
    LogicalJoin { type: Inner, on: (t1.v2 = t2.v2), output: [t1.v1, t2.v1] }
    ├─LogicalScan { table: t1, columns: [t1.v1, t1.v2] }
    └─LogicalScan { table: t2, columns: [t2.v1, t2.v2] }
- name: agg
  sql: |
    create table t (v1 bigint, v2 double precision, v3 int);
    select count(v1) from t where v2 > 2
  logical_plan: |
    LogicalProject { exprs: [count(t.v1)] }
    └─LogicalAgg { aggs: [count(t.v1)] }
      └─LogicalProject { exprs: [t.v1] }
        └─LogicalFilter { predicate: (t.v2 > 2:Int32) }
          └─LogicalScan { table: t, columns: [t.v1, t.v2, t.v3, t._row_id] }
  optimized_logical_plan: |
    LogicalAgg { aggs: [count(t.v1)] }
    └─LogicalScan { table: t, output_columns: [t.v1], required_columns: [v1, v2], predicate: (t.v2 > 2:Int32) }
- name: top n
  sql: |
    create table t (v1 int, v2 int, v3 int);
    select v3 from (select * from t order by v3, v2 limit 2) as s;
  logical_plan: |
    LogicalProject { exprs: [t.v3] }
    └─LogicalTopN { order: "[t.v3 ASC, t.v2 ASC]", limit: 2, offset: 0 }
      └─LogicalProject { exprs: [t.v1, t.v2, t.v3] }
        └─LogicalScan { table: t, columns: [t.v1, t.v2, t.v3, t._row_id] }
  optimized_logical_plan: |
    LogicalProject { exprs: [t.v3] }
    └─LogicalTopN { order: "[t.v3 ASC, t.v2 ASC]", limit: 2, offset: 0 }
      └─LogicalScan { table: t, columns: [t.v2, t.v3] }
- name: constant
  sql: |
    create table t (v1 bigint, v2 double precision, v3 int);
    select 1 from t
  logical_plan: |
    LogicalProject { exprs: [1:Int32] }
    └─LogicalScan { table: t, columns: [t.v1, t.v2, t.v3, t._row_id] }
  optimized_logical_plan: |
    LogicalProject { exprs: [1:Int32] }
    └─LogicalScan { table: t, columns: [] }
- name: constant + filter
  sql: |
    create table t (v1 bigint, v2 double precision, v3 int);
    select 1 from t where v2>1
  logical_plan: |
    LogicalProject { exprs: [1:Int32] }
    └─LogicalFilter { predicate: (t.v2 > 1:Int32) }
      └─LogicalScan { table: t, columns: [t.v1, t.v2, t.v3, t._row_id] }
  optimized_logical_plan: |
    LogicalProject { exprs: [1:Int32] }
    └─LogicalScan { table: t, output_columns: [], required_columns: [v2], predicate: (t.v2 > 1:Int32) }
- name: constant agg
  sql: |
    create table t (v1 bigint, v2 double precision, v3 int);
    select count(1) from t
  logical_plan: |
    LogicalProject { exprs: [count(1:Int32)] }
    └─LogicalAgg { aggs: [count(1:Int32)] }
      └─LogicalProject { exprs: [1:Int32] }
        └─LogicalScan { table: t, columns: [t.v1, t.v2, t.v3, t._row_id] }
  optimized_logical_plan: |
    LogicalAgg { aggs: [count(1:Int32)] }
    └─LogicalProject { exprs: [1:Int32] }
      └─LogicalScan { table: t, columns: [] }
- name: constant agg + filter
  sql: |
    create table t (v1 bigint, v2 double precision, v3 int);
    select count(1) from t where v2>1
  logical_plan: |
    LogicalProject { exprs: [count(1:Int32)] }
    └─LogicalAgg { aggs: [count(1:Int32)] }
      └─LogicalProject { exprs: [1:Int32] }
        └─LogicalFilter { predicate: (t.v2 > 1:Int32) }
          └─LogicalScan { table: t, columns: [t.v1, t.v2, t.v3, t._row_id] }
  optimized_logical_plan: |
    LogicalAgg { aggs: [count(1:Int32)] }
    └─LogicalProject { exprs: [1:Int32] }
      └─LogicalScan { table: t, output_columns: [], required_columns: [v2], predicate: (t.v2 > 1:Int32) }
- name: join + filter
  sql: |
    create table t1 (v1 int, v2 int, v3 int);
    create table t2 (v1 int, v2 int, v3 int);
    select t1.v1, t2.v1 from t1 join t2 on t1.v2 = t2.v2 where t1.v3 < 1;
  logical_plan: |
    LogicalProject { exprs: [t1.v1, t2.v1] }
    └─LogicalFilter { predicate: (t1.v3 < 1:Int32) }
      └─LogicalJoin { type: Inner, on: (t1.v2 = t2.v2), output: all }
        ├─LogicalScan { table: t1, columns: [t1.v1, t1.v2, t1.v3, t1._row_id] }
        └─LogicalScan { table: t2, columns: [t2.v1, t2.v2, t2.v3, t2._row_id] }
  optimized_logical_plan: |
    LogicalJoin { type: Inner, on: (t1.v2 = t2.v2), output: [t1.v1, t2.v1] }
    ├─LogicalScan { table: t1, output_columns: [t1.v1, t1.v2], required_columns: [v1, v2, v3], predicate: (t1.v3 < 1:Int32) }
    └─LogicalScan { table: t2, columns: [t2.v1, t2.v2] }
- name: mixed
  sql: |
    create table t (v1 bigint, v2 double precision, v3 int);
    select count(1), count(v1) from t where v2>1
  logical_plan: |
    LogicalProject { exprs: [count(1:Int32), count(t.v1)] }
    └─LogicalAgg { aggs: [count(1:Int32), count(t.v1)] }
      └─LogicalProject { exprs: [1:Int32, t.v1] }
        └─LogicalFilter { predicate: (t.v2 > 1:Int32) }
          └─LogicalScan { table: t, columns: [t.v1, t.v2, t.v3, t._row_id] }
  optimized_logical_plan: |
    LogicalAgg { aggs: [count(1:Int32), count(t.v1)] }
    └─LogicalProject { exprs: [1:Int32, t.v1] }
      └─LogicalScan { table: t, output_columns: [t.v1], required_columns: [v1, v2], predicate: (t.v2 > 1:Int32) }
- name: hop window, time_col not selected
  sql: |
    create table t1 (a int, b int, created_at timestamp);
    select a, window_end from hop(t1, created_at, interval '15' minute, interval '30' minute)
  logical_plan: |
    LogicalProject { exprs: [t1.a, window_end] }
    └─LogicalHopWindow { time_col: t1.created_at, slide: 00:15:00, size: 00:30:00, output: all }
      └─LogicalScan { table: t1, columns: [t1.a, t1.b, t1.created_at, t1._row_id] }
  optimized_logical_plan: |
    LogicalHopWindow { time_col: t1.created_at, slide: 00:15:00, size: 00:30:00, output: [t1.a, window_end] }
    └─LogicalScan { table: t1, columns: [t1.a, t1.created_at] }
  batch_plan: |
    BatchHopWindow { time_col: t1.created_at, slide: 00:15:00, size: 00:30:00, output: [t1.a, window_end] }
    └─BatchExchange { order: [], dist: Single }
      └─BatchScan { table: t1, columns: [t1.a, t1.created_at], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [a, window_end, t1._row_id(hidden)], pk_columns: [t1._row_id, window_end] }
    └─StreamHopWindow { time_col: t1.created_at, slide: 00:15:00, size: 00:30:00, output: [t1.a, window_end, t1._row_id] }
      └─StreamTableScan { table: t1, columns: [t1.a, t1.created_at, t1._row_id], pk: [t1._row_id], dist: UpstreamHashShard(t1._row_id) }
