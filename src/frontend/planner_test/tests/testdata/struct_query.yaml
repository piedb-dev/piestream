# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- sql: |
    create materialized view t as select country from s;
    select * from t;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchScan { table: t, columns: [t.country], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [country, t._row_id(hidden)], pk_columns: [t._row_id] }
    └─StreamTableScan { table: t, columns: [t.country, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
  create_source:
    row_format: protobuf
    name: s
    file: |
      syntax = "proto3";
      package test;
      message TestRecord {
        int32 id = 1;
        Country country = 3;
        int64 zipcode = 4;
        float rate = 5;
      }
      message Country {
        string address = 1;
        City city = 2;
        string zipcode = 3;
      }
      message City {
        string address = 1;
        string zipcode = 2;
      }
- sql: |
    create materialized view t as select * from s;
    select (t).country.city,(t).country,(country).city.address from t;
  logical_plan: |
    LogicalProject { exprs: [Field(t.country, 1:Int32), t.country, Field(Field(t.country, 1:Int32), 0:Int32)] }
    └─LogicalScan { table: t, columns: [t.id, t.country, t.zipcode, t.rate, t._row_id] }
  create_source:
    row_format: protobuf
    name: s
    file: |
      syntax = "proto3";
      package test;
      message TestRecord {
        int32 id = 1;
        Country country = 3;
        int64 zipcode = 4;
        float rate = 5;
      }
      message Country {
        string address = 1;
        City city = 2;
        string zipcode = 3;
      }
      message City {
        string address = 1;
        string zipcode = 2;
      }
- sql: |
    CREATE TABLE t (
      id INTEGER,
      country STRUCT<
        address VARCHAR,
        city STRUCT<address VARCHAR, zipcode VARCHAR>,
        zipcode VARCHAR
      >,
      zipcode BIGINT,
      rate FLOAT);
    select (t).country.city.*,(t.country).*,(country).city.* from t;
  logical_plan: |
    LogicalProject { exprs: [Field(Field(t.country, 1:Int32), 0:Int32), Field(Field(t.country, 1:Int32), 1:Int32), Field(t.country, 0:Int32), Field(t.country, 1:Int32), Field(t.country, 2:Int32), Field(Field(t.country, 1:Int32), 0:Int32), Field(Field(t.country, 1:Int32), 1:Int32)] }
    └─LogicalScan { table: t, columns: [t.id, t.country, t.zipcode, t.rate, t._row_id] }
- sql: |
    create materialized view t as select * from s;
    select (t).country1.city.*,(t.country2).*,(country3).city.* from t;
  logical_plan: |
    LogicalProject { exprs: [Field(Field(t.country1, 1:Int32), 0:Int32), Field(Field(t.country1, 1:Int32), 1:Int32), Field(t.country2, 0:Int32), Field(t.country2, 1:Int32), Field(t.country2, 2:Int32), Field(Field(t.country3, 1:Int32), 0:Int32), Field(Field(t.country3, 1:Int32), 1:Int32)] }
    └─LogicalScan { table: t, columns: [t.id, t.country1, t.country2, t.country3, t.zipcode, t.rate, t._row_id] }
  create_source:
    row_format: protobuf
    name: s
    file: |
      syntax = "proto3";
      package test;
      message TestRecord {
        int32 id = 1;
        Country country1 = 3;
        Country country2 = 4;
        Country country3 = 5;
        int64 zipcode = 6;
        float rate = 7;
      }
      message Country {
        string address = 1;
        City city = 2;
        string zipcode = 3;
      }
      message City {
        string address = 1;
        string zipcode = 2;
      }
- sql: |
    create materialized view t as select * from s;
    select (c).zipcode from (select (t).country.city as c from t);
  logical_plan: |
    LogicalProject { exprs: [Field(Field(t.country, 1:Int32), 1:Int32)] }
    └─LogicalProject { exprs: [Field(t.country, 1:Int32)] }
      └─LogicalScan { table: t, columns: [t.id, t.country, t.zipcode, t.rate, t._row_id] }
  create_source:
    row_format: protobuf
    name: s
    file: |
      syntax = "proto3";
      package test;
      message TestRecord {
        int32 id = 1;
        Country country = 3;
        int64 zipcode = 4;
        float rate = 5;
      }
      message Country {
        string address = 1;
        City city = 2;
        string zipcode = 3;
      }
      message City {
        string address = 1;
        string zipcode = 2;
      }
- sql: |
    create materialized view t as select * from s;
    select (c).zipcode from (select min((t).country.city) as c from t);
  logical_plan: |
    LogicalProject { exprs: [Field(min(Field(t.country, 1:Int32)), 1:Int32)] }
    └─LogicalProject { exprs: [min(Field(t.country, 1:Int32))] }
      └─LogicalAgg { aggs: [min(Field(t.country, 1:Int32))] }
        └─LogicalProject { exprs: [Field(t.country, 1:Int32)] }
          └─LogicalScan { table: t, columns: [t.id, t.country, t.zipcode, t.rate, t._row_id] }
  create_source:
    row_format: protobuf
    name: s
    file: |
      syntax = "proto3";
      package test;
      message TestRecord {
        int32 id = 1;
        Country country = 3;
        int64 zipcode = 4;
        float rate = 5;
      }
      message Country {
        string address = 1;
        City city = 2;
        string zipcode = 3;
      }
      message City {
        string address = 1;
        string zipcode = 2;
      }
- sql: |
    create materialized view t as select * from s;
    select * from (select (country).city as c from t) as vv join t on (c).zipcode=(t.country).zipcode;
  logical_plan: |
    LogicalProject { exprs: [Field(t.country, 1:Int32), t.id, t.country, t.zipcode, t.rate] }
    └─LogicalJoin { type: Inner, on: (Field(Field(t.country, 1:Int32), 1:Int32) = Field(t.country, 2:Int32)), output: all }
      ├─LogicalProject { exprs: [Field(t.country, 1:Int32)] }
      | └─LogicalScan { table: t, columns: [t.id, t.country, t.zipcode, t.rate, t._row_id] }
      └─LogicalScan { table: t, columns: [t.id, t.country, t.zipcode, t.rate, t._row_id] }
  create_source:
    row_format: protobuf
    name: s
    file: |
      syntax = "proto3";
      package test;
      message TestRecord {
        int32 id = 1;
        Country country = 3;
        int64 zipcode = 4;
        float rate = 5;
      }
      message Country {
        string address = 1;
        City city = 2;
        string zipcode = 3;
      }
      message City {
        string address = 1;
        string zipcode = 2;
      }
- sql: |
    create materialized view t as select * from s;
    select min((t.country).city.address) + max((t.country).city.address) * count(zipcode) from t;
  logical_plan: |
    LogicalProject { exprs: [(min(Field(Field(t.country, 1:Int32), 0:Int32)) + (max(Field(Field(t.country, 1:Int32), 0:Int32)) * count(t.zipcode)))] }
    └─LogicalAgg { aggs: [min(Field(Field(t.country, 1:Int32), 0:Int32)), max(Field(Field(t.country, 1:Int32), 0:Int32)), count(t.zipcode)] }
      └─LogicalProject { exprs: [Field(Field(t.country, 1:Int32), 0:Int32), t.zipcode] }
        └─LogicalScan { table: t, columns: [t.id, t.country, t.zipcode, t.rate, t._row_id] }
  create_source:
    row_format: protobuf
    name: s
    file: |
      syntax = "proto3";
      package test;
      message TestRecord {
        int32 id = 1;
        Country country = 3;
        int64 zipcode = 4;
        float rate = 5;
      }
      message Country {
        string address = 1;
        City city = 2;
        string zipcode = 3;
      }
      message City {
        int64 address = 1;
        string zipcode = 2;
      }
- sql: |
    create materialized view t as select * from s;
    select count(1), count((country).city.zipcode) from t where (country).city.address>1;
  logical_plan: |
    LogicalProject { exprs: [count(1:Int32), count(Field(Field(t.country, 1:Int32), 1:Int32))] }
    └─LogicalAgg { aggs: [count(1:Int32), count(Field(Field(t.country, 1:Int32), 1:Int32))] }
      └─LogicalProject { exprs: [1:Int32, Field(Field(t.country, 1:Int32), 1:Int32)] }
        └─LogicalFilter { predicate: (Field(Field(t.country, 1:Int32), 0:Int32) > 1:Int32) }
          └─LogicalScan { table: t, columns: [t.id, t.country, t.zipcode, t.rate, t._row_id] }
  create_source:
    row_format: protobuf
    name: s
    file: |
      syntax = "proto3";
      package test;
      message TestRecord {
        int32 id = 1;
        Country country = 3;
        int64 zipcode = 4;
        float rate = 5;
      }
      message Country {
        string address = 1;
        City city = 2;
        string zipcode = 3;
      }
      message City {
        int64 address = 1;
        string zipcode = 2;
      }
- sql: |
    create table t (v1 bigint, v2 double precision);
    select (v1).v2 from t;
  binder_error: 'Bind error: column notation .v2 applied to type bigint, which is
    not a composite type'
- sql: |
    create materialized view t as select * from s;
    select (country + country) from t;
  binder_error: |-
    Feature is not yet implemented: Add[Struct, Struct]
    Tracking issue: https://github.com/piestreamlabs/piestream/issues/112
  create_source:
    row_format: protobuf
    name: s
    file: |
      syntax = "proto3";
      package test;
      message TestRecord {
        int32 id = 1;
        Country country = 3;
        int64 zipcode = 4;
        float rate = 5;
      }
      message Country {
        string address = 1;
        string zipcode = 3;
      }
- sql: |
    create materialized view t as select * from s;
    select avg(country) from t;
  binder_error: 'Invalid input syntax: Invalid aggregation: avg(struct<address varchar,zipcode
    varchar>)'
  create_source:
    row_format: protobuf
    name: s
    file: |
      syntax = "proto3";
      package test;
      message TestRecord {
        int32 id = 1;
        Country country = 3;
        int64 zipcode = 4;
        float rate = 5;
      }
      message Country {
        string address = 1;
        string zipcode = 3;
      }
- sql: |
    create materialized view t as select * from s;
    select (country).city from t;
  binder_error: 'Bind error: column "city" not found in struct type'
  create_source:
    row_format: protobuf
    name: s
    file: |
      syntax = "proto3";
      package test;
      message TestRecord {
        int32 id = 1;
        Country country = 3;
        int64 zipcode = 4;
        float rate = 5;
      }
      message Country {
        string address = 1;
        string zipcode = 3;
      }
- sql: |
    create materialized view t as select * from s;
    select (country).address.* from t;
  binder_error: 'Bind error: type "varchar" is not composite'
  create_source:
    row_format: protobuf
    name: s
    file: |
      syntax = "proto3";
      package test;
      message TestRecord {
        int32 id = 1;
        Country country = 3;
        int64 zipcode = 4;
        float rate = 5;
      }
      message Country {
        string address = 1;
        string zipcode = 3;
      }
- sql: |
    insert into s values (1,2,(1,2,(1,2,null)));
  logical_plan: |
    LogicalInsert { table: s }
    └─LogicalValues { rows: [[1:Int32, 2:Int32, Row(1:Int32, 2:Int32, Row(1:Int32, 2:Int32, null:Int32))]], schema: Schema { fields: [*VALUES*_0.column_0:Int32, *VALUES*_0.column_1:Int32, *VALUES*_0.column_2:Struct(StructType { fields: [Int32, Int32, Struct(StructType { fields: [Int32, Int32, Int32], field_names: ["v1", "v2", "v3"] })], field_names: ["v1", "v2", "v3"] })] } }
  create_source:
    row_format: protobuf
    name: s
    file: |
      syntax = "proto3";
      package test;
      message TestRecord {
        int32 v1 = 1;
        int32 v2 = 2;
        V v3 = 3;
      }
      message V {
        int32 v1 = 1;
        int32 v2 = 2;
        U v3 = 3;
      }
      message U {
        int32 v1 = 1;
        int32 v2 = 2;
        int32 v3 = 3;
      }
    materialized: true
- sql: |
    select * from s where s.v3 = (1,2,(1,2,3));
  logical_plan: |
    LogicalProject { exprs: [s.v1, s.v2, s.v3] }
    └─LogicalFilter { predicate: (s.v3 = Row(1:Int32, 2:Int32, Row(1:Int32, 2:Int32, 3:Int32))) }
      └─LogicalScan { table: s, columns: [s._row_id, s.v1, s.v2, s.v3] }
  create_source:
    row_format: protobuf
    name: s
    file: |-
      syntax = "proto3";
      package test;
      message TestRecord {
        int32 v1 = 1;
        int32 v2 = 2;
        V v3 = 3;
      }
      message V {
        int32 v1 = 1;
        int32 v2 = 2;
        U v3 = 3;
      }
      message U {
        int32 v1 = 1;
        int32 v2 = 2;
        int32 v3 = 3;
      }
    materialized: true
- sql: |
    CREATE TABLE a (c STRUCT<i STRUCT<a INTEGER>, j INTEGER>);
    INSERT INTO a VALUES (1);
  binder_error: 'Bind error: cannot cast type "integer" to "struct<i struct<a integer>,j
    integer>" in Assign context'
