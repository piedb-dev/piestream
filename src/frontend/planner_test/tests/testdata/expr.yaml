# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- name: bind typed literal - int
  sql: |
    select int '1';
  logical_plan: |
    LogicalProject { exprs: ['1':Varchar::Int32] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- name: bind typed literal - bool
  sql: |
    SELECT bool 't'
  logical_plan: |
    LogicalProject { exprs: ['t':Varchar::Boolean] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- sql: |
    values(must_be_unimplemented_func(1));
  binder_error: |-
    Feature is not yet implemented: unsupported function: "must_be_unimplemented_func"
    Tracking issue: https://github.com/piestreamlabs/piestream/issues/112
- sql: |
    values(cast(1 as bigint));
  batch_plan: |
    BatchValues { rows: [[1:Int32::Int64]] }
- sql: |
    values(not true);
  batch_plan: |
    BatchValues { rows: [[Not(true:Boolean)]] }
- sql: |
    create table t ();
    select (((((false is not true) is true) is not false) is false) is not null) is null from t;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [IsNull(IsNotNull(IsFalse(IsNotFalse(IsTrue(IsNotTrue(false:Boolean))))))] }
      └─BatchScan { table: t, columns: [], distribution: SomeShard }
- name: bind between
  sql: |
    SELECT 1 between 2 and 3
  logical_plan: |
    LogicalProject { exprs: [((1:Int32 >= 2:Int32) AND (1:Int32 <= 3:Int32))] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- name: null eq null
  sql: |
    SELECT null = null;
  logical_plan: |
    LogicalProject { exprs: [(null:Varchar = null:Varchar)] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- name: null lt null
  sql: |
    SELECT null < null;
  logical_plan: |
    LogicalProject { exprs: [(null:Varchar < null:Varchar)] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- name: bind is distinct from
  sql: |
    SELECT 1 IS DISTINCT FROM 2
  logical_plan: |
    LogicalProject { exprs: [IsDistinctFrom(1:Int32, 2:Int32)] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- name: bind is not distinct from
  sql: |
    SELECT 1 IS NOT DISTINCT FROM 2
  logical_plan: |
    LogicalProject { exprs: [IsNotDistinctFrom(1:Int32, 2:Int32)] }
    └─LogicalValues { rows: [[]], schema: Schema { fields: [] } }
- name: in-list with aligned types
  sql: |
    SELECT 1::real in (3, 1.0, 2);
  batch_plan: |
    BatchProject { exprs: [In(1:Int32::Float32, 3:Int32::Float32, 1.0:Decimal::Float32, 2:Int32::Float32)] }
    └─BatchValues { rows: [[]] }
- name: not in-list with aligned types
  sql: |
    SELECT 1::real not in (3, 1.0, 2);
  batch_plan: |
    BatchProject { exprs: [Not(In(1:Int32::Float32, 3:Int32::Float32, 1.0:Decimal::Float32, 2:Int32::Float32))] }
    └─BatchValues { rows: [[]] }
- name: in-list with misaligned types
  sql: |
    SELECT true in (3, 1.0, 2);
  binder_error: 'Bind error: types Boolean and Int32 cannot be matched'
- name: in-list with non-const - agg
  sql: |
    create table t (v1 int);
    SELECT 1 in (3, 0.5*2, min(v1)) from t;
  batch_plan: |
    BatchProject { exprs: [(In(1:Int32::Decimal, 3:Int32::Decimal, (0.5:Decimal * 2:Int32)) OR (1:Int32 = min(min(t.v1))))] }
    └─BatchSimpleAgg { aggs: [min(min(t.v1))] }
      └─BatchExchange { order: [], dist: Single }
        └─BatchSimpleAgg { aggs: [min(t.v1)] }
          └─BatchScan { table: t, columns: [t.v1], distribution: SomeShard }
- name: in-list with non-const - scalar subquery
  sql: |
    create table t (v1 int);
    create table b (b1 int, b2 int);
    SELECT b2 from b where 1 in (3, 1.0, (select min(v1) from t));
  batch_plan: |
    BatchProject { exprs: [b.b2] }
    └─BatchFilter { predicate: (In(1:Int32::Decimal, 3:Int32::Decimal, 1.0:Decimal) OR (1:Int32 = min(min(t.v1)))) }
      └─BatchNestedLoopJoin { type: LeftOuter, predicate: true, output: all }
        ├─BatchExchange { order: [], dist: Single }
        | └─BatchScan { table: b, columns: [b.b2], distribution: SomeShard }
        └─BatchSimpleAgg { aggs: [min(min(t.v1))] }
          └─BatchExchange { order: [], dist: Single }
            └─BatchSimpleAgg { aggs: [min(t.v1)] }
              └─BatchScan { table: t, columns: [t.v1], distribution: SomeShard }
- name: in-list with non-const - correlated ref
  sql: |
    create table t (v1 int);
    create table b (b1 int, b2 int);
    SELECT b2 from b where exists (select 2 from t where v1 in (3, 1.0, b1));
  batch_plan: |
    BatchNestedLoopJoin { type: LeftSemi, predicate: (In(t.v1::Decimal, 3:Int32::Decimal, 1.0:Decimal) OR (t.v1 = b.b1)), output: [b.b2] }
    ├─BatchExchange { order: [], dist: Single }
    | └─BatchScan { table: b, columns: [b.b1, b.b2], distribution: SomeShard }
    └─BatchExchange { order: [], dist: Single }
      └─BatchProject { exprs: [t.v1, t.v1] }
        └─BatchScan { table: t, columns: [t.v1], distribution: SomeShard }
- sql: |
    select +1.0, -2.0;
  batch_plan: |
    BatchProject { exprs: [1.0:Decimal, -2.0:Decimal] }
    └─BatchValues { rows: [[]] }
- sql: |
    values(round(42.4382, 2));
  batch_plan: |
    BatchValues { rows: [[RoundDigit(42.4382:Decimal, 2:Int32)]] }
- sql: |
    values(round(42.4382));
  batch_plan: |
    BatchValues { rows: [[Round(42.4382:Decimal)]] }
- sql: |
    values(round(42));
  batch_plan: |
    BatchValues { rows: [[Round(42:Int32::Float64)]] }
- sql: |
    values(round(42, 2));
  batch_plan: |
    BatchValues { rows: [[RoundDigit(42:Int32::Decimal, 2:Int32)]] }
- sql: |
    values(round(true));
  binder_error: |-
    Feature is not yet implemented: Round[Boolean]
    Tracking issue: https://github.com/piestreamlabs/piestream/issues/112
- sql: |
    -- Single quoted literal can be treated as number without error.
    values(round('123'));
    -- When it is invalid, PostgreSQL reports error during explain, but we have to wait until execution as of now.
    -- values(round('abc'));
  batch_plan: |
    BatchValues { rows: [[Round('123':Varchar::Float64)]] }
- sql: |
    values(extract(hour from timestamp '2001-02-16 20:38:40'));
  batch_plan: |
    BatchValues { rows: [[Extract('HOUR':Varchar, '2001-02-16 20:38:40':Varchar::Timestamp)]] }
- sql: |
    values('Postgres' not like 'Post%');
  batch_plan: |
    BatchValues { rows: [[Not(Like('Postgres':Varchar, 'Post%':Varchar))]] }
- sql: |
    values(1 not like 1.23);
  binder_error: |-
    Feature is not yet implemented: Like[Int32, Decimal]
    Tracking issue: https://github.com/piestreamlabs/piestream/issues/112
- sql: |
    select length(trim(trailing '1' from '12'))+length(trim(leading '2' from '23'))+length(trim(both '3' from '34'));
  batch_plan: |
    BatchProject { exprs: [((Length(Rtrim('12':Varchar, '1':Varchar)) + Length(Ltrim('23':Varchar, '2':Varchar))) + Length(Trim('34':Varchar, '3':Varchar)))] }
    └─BatchValues { rows: [[]] }
- sql: |
    select position(replace('1','1','2'),'123') where '12' like '%1';
  batch_plan: |
    BatchProject { exprs: [Position(Replace('1':Varchar, '1':Varchar, '2':Varchar), '123':Varchar)] }
    └─BatchFilter { predicate: Like('12':Varchar, '%1':Varchar) }
      └─BatchValues { rows: [[]] }
- name: case searched form with else
  sql: |
    create table t (v1 int);
    select (case when v1=1 then 1 when v1=2 then 2 else 0.0 end) as expr from t;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [Case((t.v1 = 1:Int32), 1:Int32::Decimal, (t.v1 = 2:Int32), 2:Int32::Decimal, 0.0:Decimal)] }
      └─BatchScan { table: t, columns: [t.v1], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [expr, t._row_id(hidden)], pk_columns: [t._row_id] }
    └─StreamProject { exprs: [Case((t.v1 = 1:Int32), 1:Int32::Decimal, (t.v1 = 2:Int32), 2:Int32::Decimal, 0.0:Decimal), t._row_id] }
      └─StreamTableScan { table: t, columns: [t.v1, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
- name: case searched form without else
  sql: |
    create table t (v1 int);
    select (case when v1=1 then 1 when v1=2 then 2.1 end) from t;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [Case((t.v1 = 1:Int32), 1:Int32::Decimal, (t.v1 = 2:Int32), 2.1:Decimal)] }
      └─BatchScan { table: t, columns: [t.v1], distribution: SomeShard }
- name: case simple form
  sql: |
    create table t (v1 int);
    select (case v1 when 1 then 1 when 2.0 then 2 else 0.0 end) from t;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [Case((t.v1 = 1:Int32), 1:Int32::Decimal, (t.v1 = 2.0:Decimal), 2:Int32::Decimal, 0.0:Decimal)] }
      └─BatchScan { table: t, columns: [t.v1], distribution: SomeShard }
- name: case misaligned result types
  sql: |
    create table t (v1 int);
    select (case when v1=1 then 1 when v1=2 then 2 else true end) from t;
  binder_error: 'Bind error: types Int32 and Boolean cannot be matched'
- name: case misaligned value types
  sql: |
    create table t (v1 int);
    select (case v1 when 1 then 1 when true then 2 else 0.0 end) from t;
  binder_error: |-
    Feature is not yet implemented: Equal[Int32, Boolean]
    Tracking issue: https://github.com/piestreamlabs/piestream/issues/112
- sql: |
    create table t (v1 int);
    select nullif(v1, 1) as expr from t;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [Case((t.v1 = 1:Int32), null:Int32, t.v1)] }
      └─BatchScan { table: t, columns: [t.v1], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [expr, t._row_id(hidden)], pk_columns: [t._row_id] }
    └─StreamProject { exprs: [Case((t.v1 = 1:Int32), null:Int32, t.v1), t._row_id] }
      └─StreamTableScan { table: t, columns: [t.v1, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
- sql: |
    create table t (v1 int);
    select nullif(v1, 1, 2) from t;
  binder_error: 'Bind error: Nullif function must contain 2 arguments'
- sql: |
    create table t (v1 int);
    select nullif(v1, true) from t;
  binder_error: |-
    Feature is not yet implemented: Equal[Int32, Boolean]
    Tracking issue: https://github.com/piestreamlabs/piestream/issues/112
- sql: |
    create table t (v1 int);
    select coalesce(v1, 1) as expr from t;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [Coalesce(t.v1, 1:Int32)] }
      └─BatchScan { table: t, columns: [t.v1], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [expr, t._row_id(hidden)], pk_columns: [t._row_id] }
    └─StreamProject { exprs: [Coalesce(t.v1, 1:Int32), t._row_id] }
      └─StreamTableScan { table: t, columns: [t.v1, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
- sql: |
    create table t (v1 int);
    select coalesce(v1, 1.2) from t;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [Coalesce(t.v1::Decimal, 1.2:Decimal)] }
      └─BatchScan { table: t, columns: [t.v1], distribution: SomeShard }
- sql: |
    create table t (v1 int);
    select coalesce() from t;
  binder_error: 'Bind error: Function `coalesce` takes at least 1 arguments (0 given)'
- sql: |
    create table t (v1 int);
    select coalesce(1,true) from t;
  binder_error: 'Bind error: types Int32 and Boolean cannot be matched'
- sql: |
    create table t (v1 varchar);
    select concat_ws(v1, 1) as expr from t;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [ConcatWs(t.v1, 1:Int32::Varchar)] }
      └─BatchScan { table: t, columns: [t.v1], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [expr, t._row_id(hidden)], pk_columns: [t._row_id] }
    └─StreamProject { exprs: [ConcatWs(t.v1, 1:Int32::Varchar), t._row_id] }
      └─StreamTableScan { table: t, columns: [t.v1, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
- sql: |
    create table t (v1 varchar);
    select concat_ws(v1, 1.2) from t;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [ConcatWs(t.v1, 1.2:Decimal::Varchar)] }
      └─BatchScan { table: t, columns: [t.v1], distribution: SomeShard }
- sql: |
    create table t (v1 int);
    select concat_ws(v1, 1.2) from t;
  binder_error: 'Bind error: cannot cast type "integer" to "varchar" in Implicit context'
- sql: |
    create table t (v1 int);
    select concat_ws() from t;
  binder_error: 'Bind error: Function `concat_ws` takes at least 2 arguments (0 given)'
- sql: |
    create table t (v1 varchar, v2 int, v3 float);
    select concat(v1, v2, v3, 1) as expr from t;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [ConcatWs('':Varchar, t.v1, t.v2::Varchar, t.v3::Varchar, 1:Int32::Varchar)] }
      └─BatchScan { table: t, columns: [t.v1, t.v2, t.v3], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [expr, t._row_id(hidden)], pk_columns: [t._row_id] }
    └─StreamProject { exprs: [ConcatWs('':Varchar, t.v1, t.v2::Varchar, t.v3::Varchar, 1:Int32::Varchar), t._row_id] }
      └─StreamTableScan { table: t, columns: [t.v1, t.v2, t.v3, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
- sql: |
    create table t (v1 float);
    select concat(v1) from t;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [ConcatWs('':Varchar, t.v1::Varchar)] }
      └─BatchScan { table: t, columns: [t.v1], distribution: SomeShard }
- sql: |
    create table t (v1 int);
    select concat() from t;
  binder_error: 'Bind error: Function `Concat` takes at least 1 arguments (0 given)'
- sql: |
    select concat(':', true);
  batch_plan: |
    BatchProject { exprs: [ConcatWs('':Varchar, ':':Varchar, BoolOut(true:Boolean))] }
    └─BatchValues { rows: [[]] }
- sql: |
    select ':' || true;
  batch_plan: |
    BatchProject { exprs: [ConcatOp(':':Varchar, true:Boolean::Varchar)] }
    └─BatchValues { rows: [[]] }
- sql: |
    select substr('hello', NULL);
  batch_plan: |
    BatchProject { exprs: [Substr('hello':Varchar, null:Int32)] }
    └─BatchValues { rows: [[]] }
- sql: |
    select substr(NULL, 1);
  batch_plan: |
    BatchProject { exprs: [Substr(null:Varchar, 1:Int32)] }
    └─BatchValues { rows: [[]] }
- sql: |
    select pg_typeof('123');
  batch_plan: |
    BatchProject { exprs: ['unknown':Varchar] }
    └─BatchValues { rows: [[]] }
- sql: |
    select pg_typeof(round(null));
  batch_plan: |
    BatchProject { exprs: ['double precision':Varchar] }
    └─BatchValues { rows: [[]] }
- sql: |
    select pg_typeof(row(true, 1, 'hello'));
  batch_plan: |
    BatchProject { exprs: ['record':Varchar] }
    └─BatchValues { rows: [[]] }
- sql: |
    select pg_typeof(array[1, 2]);
  batch_plan: |
    BatchProject { exprs: ['integer[]':Varchar] }
    └─BatchValues { rows: [[]] }
- sql: |
    select pg_typeof(array[array[1, 2], array[3, 4]]);
  batch_plan: |
    BatchProject { exprs: ['integer[][]':Varchar] }
    └─BatchValues { rows: [[]] }
