# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- sql: |
    create table t1 (v1 int, v2 int);
    create table t2 (v3 int, v4 int);
    create table t3 (v5 int, v6 int);
    select * from t1, t2, t3 where t1.v1 = t2.v3 and t1.v1 = t3.v5;
  logical_plan: |
    LogicalProject { exprs: [t1.v1, t1.v2, t2.v3, t2.v4, t3.v5, t3.v6] }
    └─LogicalFilter { predicate: (t1.v1 = t2.v3) AND (t1.v1 = t3.v5) }
      └─LogicalJoin { type: Inner, on: true, output: all }
        ├─LogicalJoin { type: Inner, on: true, output: all }
        | ├─LogicalScan { table: t1, columns: [t1.v1, t1.v2, t1._row_id] }
        | └─LogicalScan { table: t2, columns: [t2.v3, t2.v4, t2._row_id] }
        └─LogicalScan { table: t3, columns: [t3.v5, t3.v6, t3._row_id] }
  stream_plan: |
    StreamMaterialize { columns: [v1, v2, v3, v4, v5, v6, t1._row_id(hidden), t2._row_id(hidden), t3._row_id(hidden)], pk_columns: [t1._row_id, t2._row_id, v1, v3, t3._row_id, v5] }
    └─StreamHashJoin { type: Inner, predicate: t1.v1 = t3.v5, output: [t1.v1, t1.v2, t2.v3, t2.v4, t3.v5, t3.v6, t1._row_id, t2._row_id, t3._row_id] }
      ├─StreamHashJoin { type: Inner, predicate: t1.v1 = t2.v3, output: [t1.v1, t1.v2, t2.v3, t2.v4, t1._row_id, t2._row_id] }
      | ├─StreamExchange { dist: HashShard(t1.v1) }
      | | └─StreamTableScan { table: t1, columns: [t1.v1, t1.v2, t1._row_id], pk: [t1._row_id], dist: UpstreamHashShard(t1._row_id) }
      | └─StreamExchange { dist: HashShard(t2.v3) }
      |   └─StreamTableScan { table: t2, columns: [t2.v3, t2.v4, t2._row_id], pk: [t2._row_id], dist: UpstreamHashShard(t2._row_id) }
      └─StreamExchange { dist: HashShard(t3.v5) }
        └─StreamTableScan { table: t3, columns: [t3.v5, t3.v6, t3._row_id], pk: [t3._row_id], dist: UpstreamHashShard(t3._row_id) }
- name: self join
  sql: |
    create table t (v1 int, v2 int);
    select t1.v1 as t1v1, t2.v1 as t2v1 from t t1 join t t2 on t1.v1 = t2.v1;
  logical_plan: |
    LogicalProject { exprs: [t.v1, t.v1] }
    └─LogicalJoin { type: Inner, on: (t.v1 = t.v1), output: all }
      ├─LogicalScan { table: t, columns: [t.v1, t.v2, t._row_id] }
      └─LogicalScan { table: t, columns: [t.v1, t.v2, t._row_id] }
  stream_plan: |
    StreamMaterialize { columns: [t1v1, t2v1, t._row_id(hidden), t._row_id#1(hidden)], pk_columns: [t._row_id, t._row_id#1, t1v1, t2v1] }
    └─StreamHashJoin { type: Inner, predicate: t.v1 = t.v1, output: [t.v1, t.v1, t._row_id, t._row_id] }
      ├─StreamExchange { dist: HashShard(t.v1) }
      | └─StreamTableScan { table: t, columns: [t.v1, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
      └─StreamExchange { dist: HashShard(t.v1) }
        └─StreamTableScan { table: t, columns: [t.v1, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
- sql: |
    create table t1 (v1 int, v2 int);
    create table t2 (v1 int, v2 int);
    create table t3 (v1 int, v2 int);
    select t1.v1 as t1_v1, t1.v2 as t1_v2, t2.v1 as t2_v1, t2.v2 as t2_v2, t3.v1 as t3_v1, t3.v2 as t3_v2 from t1 join t2 on (t1.v1 = t2.v1) join t3 on (t2.v2 = t3.v2);
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchHashJoin { type: Inner, predicate: t2.v2 = t3.v2, output: all }
      ├─BatchExchange { order: [], dist: HashShard(t2.v2) }
      | └─BatchHashJoin { type: Inner, predicate: t1.v1 = t2.v1, output: all }
      |   ├─BatchExchange { order: [], dist: HashShard(t1.v1) }
      |   | └─BatchScan { table: t1, columns: [t1.v1, t1.v2], distribution: SomeShard }
      |   └─BatchExchange { order: [], dist: HashShard(t2.v1) }
      |     └─BatchScan { table: t2, columns: [t2.v1, t2.v2], distribution: SomeShard }
      └─BatchExchange { order: [], dist: HashShard(t3.v2) }
        └─BatchScan { table: t3, columns: [t3.v1, t3.v2], distribution: SomeShard }
  batch_local_plan: |
    BatchHashJoin { type: Inner, predicate: t2.v2 = t3.v2, output: all }
    ├─BatchHashJoin { type: Inner, predicate: t1.v1 = t2.v1, output: all }
    | ├─BatchExchange { order: [], dist: Single }
    | | └─BatchScan { table: t1, columns: [t1.v1, t1.v2], distribution: SomeShard }
    | └─BatchExchange { order: [], dist: Single }
    |   └─BatchScan { table: t2, columns: [t2.v1, t2.v2], distribution: SomeShard }
    └─BatchExchange { order: [], dist: Single }
      └─BatchScan { table: t3, columns: [t3.v1, t3.v2], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [t1_v1, t1_v2, t2_v1, t2_v2, t3_v1, t3_v2, t1._row_id(hidden), t2._row_id(hidden), t3._row_id(hidden)], pk_columns: [t1._row_id, t2._row_id, t1_v1, t2_v1, t3._row_id, t2_v2, t3_v2] }
    └─StreamHashJoin { type: Inner, predicate: t2.v2 = t3.v2, output: [t1.v1, t1.v2, t2.v1, t2.v2, t3.v1, t3.v2, t1._row_id, t2._row_id, t3._row_id] }
      ├─StreamExchange { dist: HashShard(t2.v2) }
      | └─StreamHashJoin { type: Inner, predicate: t1.v1 = t2.v1, output: [t1.v1, t1.v2, t2.v1, t2.v2, t1._row_id, t2._row_id] }
      |   ├─StreamExchange { dist: HashShard(t1.v1) }
      |   | └─StreamTableScan { table: t1, columns: [t1.v1, t1.v2, t1._row_id], pk: [t1._row_id], dist: UpstreamHashShard(t1._row_id) }
      |   └─StreamExchange { dist: HashShard(t2.v1) }
      |     └─StreamTableScan { table: t2, columns: [t2.v1, t2.v2, t2._row_id], pk: [t2._row_id], dist: UpstreamHashShard(t2._row_id) }
      └─StreamExchange { dist: HashShard(t3.v2) }
        └─StreamTableScan { table: t3, columns: [t3.v1, t3.v2, t3._row_id], pk: [t3._row_id], dist: UpstreamHashShard(t3._row_id) }
- sql: |
    create table t1 (v1 int, v2 int);
    create table t2 (v1 int, v2 int);
    select t1.v2 as t1_v2, t2.v2 as t2_v2 from t1 join t2 on t1.v1 = t2.v1;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchHashJoin { type: Inner, predicate: t1.v1 = t2.v1, output: [t1.v2, t2.v2] }
      ├─BatchExchange { order: [], dist: HashShard(t1.v1) }
      | └─BatchScan { table: t1, columns: [t1.v1, t1.v2], distribution: SomeShard }
      └─BatchExchange { order: [], dist: HashShard(t2.v1) }
        └─BatchScan { table: t2, columns: [t2.v1, t2.v2], distribution: SomeShard }
  batch_local_plan: |
    BatchHashJoin { type: Inner, predicate: t1.v1 = t2.v1, output: [t1.v2, t2.v2] }
    ├─BatchExchange { order: [], dist: Single }
    | └─BatchScan { table: t1, columns: [t1.v1, t1.v2], distribution: SomeShard }
    └─BatchExchange { order: [], dist: Single }
      └─BatchScan { table: t2, columns: [t2.v1, t2.v2], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [t1_v2, t2_v2, t1._row_id(hidden), t1.v1(hidden), t2._row_id(hidden), t2.v1(hidden)], pk_columns: [t1._row_id, t2._row_id, t1.v1, t2.v1] }
    └─StreamHashJoin { type: Inner, predicate: t1.v1 = t2.v1, output: [t1.v2, t2.v2, t1._row_id, t1.v1, t2._row_id, t2.v1] }
      ├─StreamExchange { dist: HashShard(t1.v1) }
      | └─StreamTableScan { table: t1, columns: [t1.v1, t1.v2, t1._row_id], pk: [t1._row_id], dist: UpstreamHashShard(t1._row_id) }
      └─StreamExchange { dist: HashShard(t2.v1) }
        └─StreamTableScan { table: t2, columns: [t2.v1, t2.v2, t2._row_id], pk: [t2._row_id], dist: UpstreamHashShard(t2._row_id) }
- sql: |
    create table t1 (v1 int, v2 int);
    create table t2 (v1 int, v2 int);
    select t1.v2 as t1_v2, t2.v2 as t2_v2 from t1 join t2 on t1.v1 > t2.v1 and t1.v2 < 10;
  batch_plan: |
    BatchNestedLoopJoin { type: Inner, predicate: (t1.v1 > t2.v1), output: [t1.v2, t2.v2] }
    ├─BatchExchange { order: [], dist: Single }
    | └─BatchFilter { predicate: (t1.v2 < 10:Int32) }
    |   └─BatchScan { table: t1, columns: [t1.v1, t1.v2], distribution: SomeShard }
    └─BatchExchange { order: [], dist: Single }
      └─BatchScan { table: t2, columns: [t2.v1, t2.v2], distribution: SomeShard }
  batch_local_plan: |
    BatchNestedLoopJoin { type: Inner, predicate: (t1.v1 > t2.v1), output: [t1.v2, t2.v2] }
    ├─BatchExchange { order: [], dist: Single }
    | └─BatchFilter { predicate: (t1.v2 < 10:Int32) }
    |   └─BatchScan { table: t1, columns: [t1.v1, t1.v2], distribution: SomeShard }
    └─BatchExchange { order: [], dist: Single }
      └─BatchScan { table: t2, columns: [t2.v1, t2.v2], distribution: SomeShard }
- sql: |
    create table t1 (v1 int, v2 int);
    create table t2 (v1 int, v3 int);
    select * from t1 join t2 using(v1);
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchHashJoin { type: Inner, predicate: t1.v1 = t2.v1, output: [t1.v1, t1.v2, t2.v3] }
      ├─BatchExchange { order: [], dist: HashShard(t1.v1) }
      | └─BatchScan { table: t1, columns: [t1.v1, t1.v2], distribution: SomeShard }
      └─BatchExchange { order: [], dist: HashShard(t2.v1) }
        └─BatchScan { table: t2, columns: [t2.v1, t2.v3], distribution: SomeShard }
- sql: |
    create table ab (a int, b int);
    create table bc (b int, c int);
    create table ca (c int, a int);
    select * from ab join bc using(b) join ca using(c);
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchHashJoin { type: Inner, predicate: bc.c = ca.c, output: [bc.c, ab.b, ab.a, ca.a] }
      ├─BatchExchange { order: [], dist: HashShard(bc.c) }
      | └─BatchHashJoin { type: Inner, predicate: ab.b = bc.b, output: [ab.a, ab.b, bc.c] }
      |   ├─BatchExchange { order: [], dist: HashShard(ab.b) }
      |   | └─BatchScan { table: ab, columns: [ab.a, ab.b], distribution: SomeShard }
      |   └─BatchExchange { order: [], dist: HashShard(bc.b) }
      |     └─BatchScan { table: bc, columns: [bc.b, bc.c], distribution: SomeShard }
      └─BatchExchange { order: [], dist: HashShard(ca.c) }
        └─BatchScan { table: ca, columns: [ca.c, ca.a], distribution: SomeShard }
- name: Only push to left
  sql: |
    create table t1 (v1 int, v2 int);
    create table t2 (v1 int, v2 int);
    select * from t1 left join t2 where t1.v2 > 100;
  optimized_logical_plan: |
    LogicalJoin { type: LeftOuter, on: true, output: all }
    ├─LogicalScan { table: t1, output_columns: [t1.v1, t1.v2], required_columns: [v1, v2], predicate: (t1.v2 > 100:Int32) }
    └─LogicalScan { table: t2, columns: [t2.v1, t2.v2] }
- name: Only push to right
  sql: |
    create table t1 (v1 int, v2 int);
    create table t2 (v1 int, v2 int);
    select * from t1 right join t2 where t2.v2 > 100;
  optimized_logical_plan: |
    LogicalJoin { type: LeftOuter, on: true, output: [t1.v1, t1.v2, t2.v1, t2.v2] }
    ├─LogicalScan { table: t2, output_columns: [t2.v1, t2.v2], required_columns: [v1, v2], predicate: (t2.v2 > 100:Int32) }
    └─LogicalScan { table: t1, columns: [t1.v1, t1.v2] }
- name: Push to left, right and on
  sql: |
    create table t1 (v1 int, v2 int);
    create table t2 (v1 int, v2 int);
    select * from t1, t2 where t1.v1 > 100 and t2.v1 < 1000 and t1.v2 = t2.v2;
  optimized_logical_plan: |
    LogicalJoin { type: Inner, on: (t1.v2 = t2.v2), output: all }
    ├─LogicalScan { table: t1, output_columns: [t1.v1, t1.v2], required_columns: [v1, v2], predicate: (t1.v1 > 100:Int32) }
    └─LogicalScan { table: t2, output_columns: [t2.v1, t2.v2], required_columns: [v1, v2], predicate: (t2.v1 < 1000:Int32) }
- name: Left & right has same SomeShard distribution. There should still be exchanges
    below hash join
  sql: |
    create table t(x int);
    create index i on t(x);
    select i.x as ix, ii.x as iix from i join i as ii on i.x=ii.x;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchHashJoin { type: Inner, predicate: i.x = i.x, output: all }
      ├─BatchExchange { order: [], dist: HashShard(i.x) }
      | └─BatchScan { table: i, columns: [i.x], distribution: UpstreamHashShard(i.x) }
      └─BatchExchange { order: [], dist: HashShard(i.x) }
        └─BatchScan { table: i, columns: [i.x], distribution: UpstreamHashShard(i.x) }
  stream_plan: |
    StreamMaterialize { columns: [ix, iix, i.t._row_id(hidden), i.t._row_id#1(hidden)], pk_columns: [i.t._row_id, i.t._row_id#1, ix, iix] }
    └─StreamHashJoin { type: Inner, predicate: i.x = i.x, output: [i.x, i.x, i.t._row_id, i.t._row_id] }
      ├─StreamExchange { dist: HashShard(i.x) }
      | └─StreamTableScan { table: i, columns: [i.x, i.t._row_id], pk: [i.t._row_id], dist: UpstreamHashShard(i.x) }
      └─StreamExchange { dist: HashShard(i.x) }
        └─StreamTableScan { table: i, columns: [i.x, i.t._row_id], pk: [i.t._row_id], dist: UpstreamHashShard(i.x) }
- name: Left & right has same SomeShard distribution. There should still be exchanges
    below hash join
  sql: |
    create table t(x int);
    create index i on t(x);
    select i.x as ix, t.x as tx from i join t on i.x=t.x;
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchHashJoin { type: Inner, predicate: i.x = t.x, output: all }
      ├─BatchExchange { order: [], dist: HashShard(i.x) }
      | └─BatchScan { table: i, columns: [i.x], distribution: UpstreamHashShard(i.x) }
      └─BatchExchange { order: [], dist: HashShard(t.x) }
        └─BatchScan { table: t, columns: [t.x], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [ix, tx, i.t._row_id(hidden), t._row_id(hidden)], pk_columns: [i.t._row_id, t._row_id, ix, tx] }
    └─StreamHashJoin { type: Inner, predicate: i.x = t.x, output: [i.x, t.x, i.t._row_id, t._row_id] }
      ├─StreamExchange { dist: HashShard(i.x) }
      | └─StreamTableScan { table: i, columns: [i.x, i.t._row_id], pk: [i.t._row_id], dist: UpstreamHashShard(i.x) }
      └─StreamExchange { dist: HashShard(t.x) }
        └─StreamTableScan { table: t, columns: [t.x, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
- name: Left & right has same HashShard distribution. There should be no exchange
    below hash join
  sql: |
    create table t(x int);
    create index i on t(x);
    select * from
      (select * from i join i as ii using (x)) t1
    full join
      (select * from i join i as ii using (x)) t2
    using (x);
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [Coalesce(i.x, i.x)] }
      └─BatchHashJoin { type: FullOuter, predicate: i.x = i.x, output: all }
        ├─BatchHashJoin { type: Inner, predicate: i.x = i.x, output: [i.x] }
        | ├─BatchExchange { order: [], dist: HashShard(i.x) }
        | | └─BatchScan { table: i, columns: [i.x], distribution: UpstreamHashShard(i.x) }
        | └─BatchExchange { order: [], dist: HashShard(i.x) }
        |   └─BatchScan { table: i, columns: [i.x], distribution: UpstreamHashShard(i.x) }
        └─BatchHashJoin { type: Inner, predicate: i.x = i.x, output: [i.x] }
          ├─BatchExchange { order: [], dist: HashShard(i.x) }
          | └─BatchScan { table: i, columns: [i.x], distribution: UpstreamHashShard(i.x) }
          └─BatchExchange { order: [], dist: HashShard(i.x) }
            └─BatchScan { table: i, columns: [i.x], distribution: UpstreamHashShard(i.x) }
  stream_plan: |
    StreamMaterialize { columns: [x, i.t._row_id(hidden), i.t._row_id#1(hidden), i.x(hidden), i.x#1(hidden), i.t._row_id#2(hidden), i.t._row_id#3(hidden), i.x#2(hidden), i.x#3(hidden)], pk_columns: [i.t._row_id, i.t._row_id#1, i.x, i.x#1, i.t._row_id#2, i.t._row_id#3, i.x#2, i.x#3] }
    └─StreamExchange { dist: HashShard(i.t._row_id, i.t._row_id, i.x, i.x, i.t._row_id, i.t._row_id, i.x, i.x) }
      └─StreamProject { exprs: [Coalesce(i.x, i.x), i.t._row_id, i.t._row_id, i.x, i.x, i.t._row_id, i.t._row_id, i.x, i.x] }
        └─StreamHashJoin { type: FullOuter, predicate: i.x = i.x, output: [i.x, i.x, i.t._row_id, i.t._row_id, i.x, i.t._row_id, i.t._row_id, i.x] }
          ├─StreamHashJoin { type: Inner, predicate: i.x = i.x, output: [i.x, i.t._row_id, i.t._row_id, i.x] }
          | ├─StreamExchange { dist: HashShard(i.x) }
          | | └─StreamTableScan { table: i, columns: [i.x, i.t._row_id], pk: [i.t._row_id], dist: UpstreamHashShard(i.x) }
          | └─StreamExchange { dist: HashShard(i.x) }
          |   └─StreamTableScan { table: i, columns: [i.x, i.t._row_id], pk: [i.t._row_id], dist: UpstreamHashShard(i.x) }
          └─StreamHashJoin { type: Inner, predicate: i.x = i.x, output: [i.x, i.t._row_id, i.t._row_id, i.x] }
            ├─StreamExchange { dist: HashShard(i.x) }
            | └─StreamTableScan { table: i, columns: [i.x, i.t._row_id], pk: [i.t._row_id], dist: UpstreamHashShard(i.x) }
            └─StreamExchange { dist: HashShard(i.x) }
              └─StreamTableScan { table: i, columns: [i.x, i.t._row_id], pk: [i.t._row_id], dist: UpstreamHashShard(i.x) }
- name: Use lookup join
  sql: |
    create table t1 (v1 int, v2 int);
    create table t2 (v1 int, v2 int);
    create materialized view t3 as select v1, count(v2) as v2 from t2 group by v1;
    select * from t1 join t3 where t1.v2 = t3.v1;
  batch_local_plan: |
    BatchLookupJoin { type: Inner, predicate: t1.v2 = t3.v1, output: all }
    └─BatchExchange { order: [], dist: Single }
      └─BatchScan { table: t1, columns: [t1.v1, t1.v2], distribution: SomeShard }
  with_config_map:
    QUERY_MODE: local
    RW_BATCH_ENABLE_LOOKUP_JOIN: 'true'
- name: Ensure correct binding of join with USING clause
  sql: |
    create table t1(v1 varchar);
    create table t2(v1 varchar);
    create table t3(v2 varchar);
    select * from t3, t1 join t2 using (v1);
  logical_plan: |
    LogicalProject { exprs: [t1.v1, t3.v2] }
    └─LogicalJoin { type: Inner, on: true, output: all }
      ├─LogicalScan { table: t3, columns: [t3.v2, t3._row_id] }
      └─LogicalJoin { type: Inner, on: (t1.v1 = t2.v1), output: all }
        ├─LogicalScan { table: t1, columns: [t1.v1, t1._row_id] }
        └─LogicalScan { table: t2, columns: [t2.v1, t2._row_id] }
- name: Ensure correct binding of join with ON clause
  sql: |
    create table t1(v1 varchar);
    create table t2(v2 varchar);
    create table t3(v3 varchar);
    select * from t3, t1 join t2 on v1 = v2;
  logical_plan: |
    LogicalProject { exprs: [t3.v3, t1.v1, t2.v2] }
    └─LogicalJoin { type: Inner, on: true, output: all }
      ├─LogicalScan { table: t3, columns: [t3.v3, t3._row_id] }
      └─LogicalJoin { type: Inner, on: (t1.v1 = t2.v2), output: all }
        ├─LogicalScan { table: t1, columns: [t1.v1, t1._row_id] }
        └─LogicalScan { table: t2, columns: [t2.v2, t2._row_id] }
- name: Ensure correct binding with USING clause with left outer join
  sql: |
    create table t1(v1 varchar);
    create table t2(v1 varchar);
    create table t3(v2 varchar);
    select * from t3, t1 left join t2 using (v1);
  logical_plan: |
    LogicalProject { exprs: [t1.v1, t3.v2] }
    └─LogicalJoin { type: Inner, on: true, output: all }
      ├─LogicalScan { table: t3, columns: [t3.v2, t3._row_id] }
      └─LogicalJoin { type: LeftOuter, on: (t1.v1 = t2.v1), output: all }
        ├─LogicalScan { table: t1, columns: [t1.v1, t1._row_id] }
        └─LogicalScan { table: t2, columns: [t2.v1, t2._row_id] }
- name: Ensure correct binding with ON clause with left outer join
  sql: |
    create table t1(v1 varchar);
    create table t2(v2 varchar);
    create table t3(v3 varchar);
    select * from t3, t1 left join t2 on v1 = v2;
  logical_plan: |
    LogicalProject { exprs: [t3.v3, t1.v1, t2.v2] }
    └─LogicalJoin { type: Inner, on: true, output: all }
      ├─LogicalScan { table: t3, columns: [t3.v3, t3._row_id] }
      └─LogicalJoin { type: LeftOuter, on: (t1.v1 = t2.v2), output: all }
        ├─LogicalScan { table: t1, columns: [t1.v1, t1._row_id] }
        └─LogicalScan { table: t2, columns: [t2.v2, t2._row_id] }
- name: Ensure that ON clause cannot reference correlated columns
  sql: |
    create table a(a1 int);
    create table b(b1 int);
    create table c(c1 int);
    select * from a, b join c on a1 + b1 = c1;
  binder_error: 'Item not found: Invalid column: a1'
- sql: |
    create table a(a1 int);
    create table b(b1 int);
    select * from a join lateral (select * from b where a1 = b1);
  binder_error: |-
    Feature is not yet implemented: lateral subqueries are not yet supported
    Tracking issue: https://github.com/piestreamlabs/piestream/issues/3815
- name: Ensure that natural joins bind the correct columns
  sql: |
    create table a(x int);
    create table b(x int);
    create table c(y int);
    select * from a natural join b natural join c;
  logical_plan: |
    LogicalProject { exprs: [a.x, c.y] }
    └─LogicalJoin { type: Inner, on: true, output: all }
      ├─LogicalJoin { type: Inner, on: (a.x = b.x), output: all }
      | ├─LogicalScan { table: a, columns: [a.x, a._row_id] }
      | └─LogicalScan { table: b, columns: [b.x, b._row_id] }
      └─LogicalScan { table: c, columns: [c.y, c._row_id] }
- name: Ensure that natural joins can disambiguate columns
  sql: |
    create table a(x int);
    create table b(x int);
    select x, a.x, b.x from a natural join b;
  logical_plan: |
    LogicalProject { exprs: [a.x, a.x, b.x] }
    └─LogicalJoin { type: Inner, on: (a.x = b.x), output: all }
      ├─LogicalScan { table: a, columns: [a.x, a._row_id] }
      └─LogicalScan { table: b, columns: [b.x, b._row_id] }
- name: Ensure that natural joins bind the correct columns
  sql: |
    create table a(x int);
    create table b(x int);
    create table c(y int);
    select * from a natural join b natural join c;
  logical_plan: |
    LogicalProject { exprs: [a.x, c.y] }
    └─LogicalJoin { type: Inner, on: true, output: all }
      ├─LogicalJoin { type: Inner, on: (a.x = b.x), output: all }
      | ├─LogicalScan { table: a, columns: [a.x, a._row_id] }
      | └─LogicalScan { table: b, columns: [b.x, b._row_id] }
      └─LogicalScan { table: c, columns: [c.y, c._row_id] }
- name: Ensure that natural joins can disambiguate columns
  sql: |
    create table a(x int);
    create table b(x int);
    select x, a.x, b.x from a natural join b;
  logical_plan: |
    LogicalProject { exprs: [a.x, a.x, b.x] }
    └─LogicalJoin { type: Inner, on: (a.x = b.x), output: all }
      ├─LogicalScan { table: a, columns: [a.x, a._row_id] }
      └─LogicalScan { table: b, columns: [b.x, b._row_id] }
- name: Ensure that natural joins bind the correct columns
  sql: |
    create table a(x int);
    create table b(x int);
    create table c(y int);
    select * from a natural join b natural join c;
  logical_plan: |
    LogicalProject { exprs: [a.x, c.y] }
    └─LogicalJoin { type: Inner, on: true, output: all }
      ├─LogicalJoin { type: Inner, on: (a.x = b.x), output: all }
      | ├─LogicalScan { table: a, columns: [a.x, a._row_id] }
      | └─LogicalScan { table: b, columns: [b.x, b._row_id] }
      └─LogicalScan { table: c, columns: [c.y, c._row_id] }
- name: Ensure that natural joins bind the correct columns
  sql: |
    create table a(x int);
    create table b(x int);
    select x from a natural join b;
  logical_plan: |
    LogicalProject { exprs: [a.x] }
    └─LogicalJoin { type: Inner, on: (a.x = b.x), output: all }
      ├─LogicalScan { table: a, columns: [a.x, a._row_id] }
      └─LogicalScan { table: b, columns: [b.x, b._row_id] }
- name: Ensure that natural joins bind the correct columns
  sql: |
    create table a(x int);
    create table b(x int);
    select x from a natural left join b;
  logical_plan: |
    LogicalProject { exprs: [a.x] }
    └─LogicalJoin { type: LeftOuter, on: (a.x = b.x), output: all }
      ├─LogicalScan { table: a, columns: [a.x, a._row_id] }
      └─LogicalScan { table: b, columns: [b.x, b._row_id] }
- name: Ensure that natural joins bind the correct columns
  sql: |
    create table a(x int);
    create table b(x int);
    select x, a.x, b.x from a natural right join b;
  logical_plan: |
    LogicalProject { exprs: [b.x, a.x, b.x] }
    └─LogicalJoin { type: RightOuter, on: (a.x = b.x), output: all }
      ├─LogicalScan { table: a, columns: [a.x, a._row_id] }
      └─LogicalScan { table: b, columns: [b.x, b._row_id] }
- name: Ensure that natural joins bind the correct columns
  sql: |
    create table a(x int);
    create table b(x int);
    select x, a.x, b.x from a natural full join b;
  logical_plan: |
    LogicalProject { exprs: [Coalesce(a.x, b.x), a.x, b.x] }
    └─LogicalJoin { type: FullOuter, on: (a.x = b.x), output: all }
      ├─LogicalScan { table: a, columns: [a.x, a._row_id] }
      └─LogicalScan { table: b, columns: [b.x, b._row_id] }
- name: Ensure that nested natural joins bind and disambiguate columns
  sql: |
    create table a(x int, y int);
    create table b(x int, z int);
    create table c(x int, a int);
    select x, a.x, b.x, c.x from a natural join b natural join c;
  logical_plan: |
    LogicalProject { exprs: [a.x, a.x, b.x, c.x] }
    └─LogicalJoin { type: Inner, on: (a.x = c.x), output: all }
      ├─LogicalJoin { type: Inner, on: (a.x = b.x), output: all }
      | ├─LogicalScan { table: a, columns: [a.x, a.y, a._row_id] }
      | └─LogicalScan { table: b, columns: [b.x, b.z, b._row_id] }
      └─LogicalScan { table: c, columns: [c.x, c.a, c._row_id] }
- name: Ensure that nested natural joins bind and disambiguate columns
  sql: |
    create table a(x int, y int);
    create table b(x int, z int);
    create table c(x int, a int);
    select x, a.x, b.x, c.x from a natural full join b natural full join c;
  logical_plan: |
    LogicalProject { exprs: [Coalesce(a.x, b.x, c.x), a.x, b.x, c.x] }
    └─LogicalJoin { type: FullOuter, on: (Coalesce(a.x, b.x) = c.x), output: all }
      ├─LogicalJoin { type: FullOuter, on: (a.x = b.x), output: all }
      | ├─LogicalScan { table: a, columns: [a.x, a.y, a._row_id] }
      | └─LogicalScan { table: b, columns: [b.x, b.z, b._row_id] }
      └─LogicalScan { table: c, columns: [c.x, c.a, c._row_id] }
  optimized_logical_plan: |
    LogicalProject { exprs: [Coalesce(a.x, b.x, c.x), a.x, b.x, c.x] }
    └─LogicalJoin { type: FullOuter, on: (Coalesce(a.x, b.x) = c.x), output: [a.x, b.x, c.x] }
      ├─LogicalProject { exprs: [a.x, b.x, Coalesce(a.x, b.x)] }
      | └─LogicalJoin { type: FullOuter, on: (a.x = b.x), output: all }
      |   ├─LogicalScan { table: a, columns: [a.x] }
      |   └─LogicalScan { table: b, columns: [b.x] }
      └─LogicalProject { exprs: [c.x, c.x] }
        └─LogicalScan { table: c, columns: [c.x] }
- name: Ensure that nested natural joins bind and disambiguate columns
  sql: |
    create table a(a int, y int);
    create table b(x int, z int);
    create table c(x int, a int);
    select a, x, a.a, c.a, b.x, c.x from a natural full join b natural full join c;
  logical_plan: |
    LogicalProject { exprs: [Coalesce(a.a, c.a), Coalesce(b.x, c.x), a.a, c.a, b.x, c.x] }
    └─LogicalJoin { type: FullOuter, on: (a.a = c.a) AND (b.x = c.x), output: all }
      ├─LogicalJoin { type: FullOuter, on: true, output: all }
      | ├─LogicalScan { table: a, columns: [a.a, a.y, a._row_id] }
      | └─LogicalScan { table: b, columns: [b.x, b.z, b._row_id] }
      └─LogicalScan { table: c, columns: [c.x, c.a, c._row_id] }
- name: Ensure error on non-existent USING col
  sql: |
    create table t1(v1 int, v2 int);
    create table t2(v1 int, v3 int);
    select * from t1 join t2 using (v2);
  binder_error: 'Item not found: column "v2" specified in USING clause does not exist
    in right table'
- name: Ensure error on non-existent USING col
  sql: |
    create table t1(v1 int, v2 int);
    create table t2(v1 int, v3 int);
    select * from t1 join t2 using (v3);
  binder_error: 'Item not found: column "v3" specified in USING clause does not exist
    in left table'
- name: Ensure that we can correctly bind nested joins
  sql: |
    create table t1(v1 int, v2 int);
    create table t2(v3 int, v4 int);
    create table t3(v5 int, v6 int);
    create table t4(v7 int, v8 int);
    select * from (t1 join t2 on v1=v3) full join (t3 join t4 on v5=v7) on v2=v6 and v4=v8;
  logical_plan: |
    LogicalProject { exprs: [t1.v1, t1.v2, t2.v3, t2.v4, t3.v5, t3.v6, t4.v7, t4.v8] }
    └─LogicalJoin { type: FullOuter, on: (t1.v2 = t3.v6) AND (t2.v4 = t4.v8), output: all }
      ├─LogicalJoin { type: Inner, on: (t1.v1 = t2.v3), output: all }
      | ├─LogicalScan { table: t1, columns: [t1.v1, t1.v2, t1._row_id] }
      | └─LogicalScan { table: t2, columns: [t2.v3, t2.v4, t2._row_id] }
      └─LogicalJoin { type: Inner, on: (t3.v5 = t4.v7), output: all }
        ├─LogicalScan { table: t3, columns: [t3.v5, t3.v6, t3._row_id] }
        └─LogicalScan { table: t4, columns: [t4.v7, t4.v8, t4._row_id] }
- name: Ensure that we can correctly bind nested joins with ambiguous column names
  sql: |
    create table t1(x int);
    create table t2(x int);
    create table t3(x int);
    select *, x, t1.x, t2.x, t3.x from t1 full join (t2 full join t3 using (x)) using (x);
  logical_plan: |
    LogicalProject { exprs: [Coalesce(t1.x, t2.x, t3.x), Coalesce(t1.x, t2.x, t3.x), t1.x, t2.x, t3.x] }
    └─LogicalJoin { type: FullOuter, on: (t1.x = Coalesce(t2.x, t3.x)), output: all }
      ├─LogicalScan { table: t1, columns: [t1.x, t1._row_id] }
      └─LogicalJoin { type: FullOuter, on: (t2.x = t3.x), output: all }
        ├─LogicalScan { table: t2, columns: [t2.x, t2._row_id] }
        └─LogicalScan { table: t3, columns: [t3.x, t3._row_id] }
- name: Ensure that non-trivial ambiguous references can be resolved
  sql: |
    create table a(x int);
    create table b(x int);
    select 2 * x as Y, x + x as Z from a natural full join b where 2 * x < 10 order by x + x;
  logical_plan: |
    LogicalProject { exprs: [(2:Int32 * Coalesce(a.x, b.x)), (Coalesce(a.x, b.x) + Coalesce(a.x, b.x))] }
    └─LogicalProject { exprs: [(2:Int32 * Coalesce(a.x, b.x)), (Coalesce(a.x, b.x) + Coalesce(a.x, b.x)), (Coalesce(a.x, b.x) + Coalesce(a.x, b.x))] }
      └─LogicalFilter { predicate: ((2:Int32 * Coalesce(a.x, b.x)) < 10:Int32) }
        └─LogicalJoin { type: FullOuter, on: (a.x = b.x), output: all }
          ├─LogicalScan { table: a, columns: [a.x, a._row_id] }
          └─LogicalScan { table: b, columns: [b.x, b._row_id] }
  batch_plan: |
    BatchProject { exprs: [(2:Int32 * Coalesce(a.x, b.x)), (Coalesce(a.x, b.x) + Coalesce(a.x, b.x))] }
    └─BatchExchange { order: [(Coalesce(a.x, b.x) + Coalesce(a.x, b.x)) ASC], dist: Single }
      └─BatchSort { order: [(Coalesce(a.x, b.x) + Coalesce(a.x, b.x)) ASC] }
        └─BatchProject { exprs: [(2:Int32 * Coalesce(a.x, b.x)), (Coalesce(a.x, b.x) + Coalesce(a.x, b.x)), (Coalesce(a.x, b.x) + Coalesce(a.x, b.x))] }
          └─BatchFilter { predicate: ((2:Int32 * Coalesce(a.x, b.x)) < 10:Int32) }
            └─BatchHashJoin { type: FullOuter, predicate: a.x = b.x, output: all }
              ├─BatchExchange { order: [], dist: HashShard(a.x) }
              | └─BatchScan { table: a, columns: [a.x], distribution: SomeShard }
              └─BatchExchange { order: [], dist: HashShard(b.x) }
                └─BatchScan { table: b, columns: [b.x], distribution: SomeShard }
  stream_plan: |
    StreamMaterialize { columns: [y, z, (Coalesce(a.x, b.x) + Coalesce(a.x, b.x))(hidden), a._row_id(hidden), b._row_id(hidden), a.x(hidden), b.x(hidden)], pk_columns: [a._row_id, b._row_id, a.x, b.x], order_descs: [(Coalesce(a.x, b.x) + Coalesce(a.x, b.x)), a._row_id, b._row_id, a.x, b.x] }
    └─StreamExchange { dist: HashShard(a._row_id, b._row_id, a.x, b.x) }
      └─StreamProject { exprs: [(2:Int32 * Coalesce(a.x, b.x)), (Coalesce(a.x, b.x) + Coalesce(a.x, b.x)), (Coalesce(a.x, b.x) + Coalesce(a.x, b.x)), a._row_id, b._row_id, a.x, b.x] }
        └─StreamFilter { predicate: ((2:Int32 * Coalesce(a.x, b.x)) < 10:Int32) }
          └─StreamHashJoin { type: FullOuter, predicate: a.x = b.x, output: [a.x, b.x, a._row_id, b._row_id] }
            ├─StreamExchange { dist: HashShard(a.x) }
            | └─StreamTableScan { table: a, columns: [a.x, a._row_id], pk: [a._row_id], dist: UpstreamHashShard(a._row_id) }
            └─StreamExchange { dist: HashShard(b.x) }
              └─StreamTableScan { table: b, columns: [b.x, b._row_id], pk: [b._row_id], dist: UpstreamHashShard(b._row_id) }
- sql: |
    CREATE TABLE test (a INTEGER, b INTEGER);
    CREATE TABLE test2 (a INTEGER, c INTEGER);
    SELECT test.a, b, c FROM test, test2 WHERE test.a = test2.a AND test.b <> test2.c ORDER BY test.a;
  logical_plan: |
    LogicalProject { exprs: [test.a, test.b, test2.c] }
    └─LogicalProject { exprs: [test.a, test.b, test2.c, test.a] }
      └─LogicalFilter { predicate: (test.a = test2.a) AND (test.b <> test2.c) }
        └─LogicalJoin { type: Inner, on: true, output: all }
          ├─LogicalScan { table: test, columns: [test.a, test.b, test._row_id] }
          └─LogicalScan { table: test2, columns: [test2.a, test2.c, test2._row_id] }
  optimized_logical_plan: |
    LogicalJoin { type: Inner, on: (test.a = test2.a) AND (test.b <> test2.c), output: [test.a, test.b, test2.c, test.a] }
    ├─LogicalScan { table: test, columns: [test.a, test.b] }
    └─LogicalScan { table: test2, columns: [test2.a, test2.c] }
  batch_plan: |
    BatchProject { exprs: [test.a, test.b, test2.c] }
    └─BatchExchange { order: [test.a ASC], dist: Single }
      └─BatchSort { order: [test.a ASC] }
        └─BatchProject { exprs: [test.a, test.b, test2.c, test.a] }
          └─BatchFilter { predicate: (test.b <> test2.c) }
            └─BatchHashJoin { type: Inner, predicate: test.a = test2.a, output: all }
              ├─BatchExchange { order: [], dist: HashShard(test.a) }
              | └─BatchScan { table: test, columns: [test.a, test.b], distribution: SomeShard }
              └─BatchExchange { order: [], dist: HashShard(test2.a) }
                └─BatchScan { table: test2, columns: [test2.a, test2.c], distribution: SomeShard }
- name: Use lookup join with predicate
  sql: |
    create table t1 (v1 int, v2 int);
    create table t2 (v1 int, v2 int);
    create materialized view t3 as select v1, count(v2) as v2 from t2 group by v1;
    select * from t1 join t3 where t1.v2 = t3.v1 and t3.v1 > 1;
  optimized_logical_plan: |
    LogicalJoin { type: Inner, on: (t1.v2 = t3.v1), output: all }
    ├─LogicalScan { table: t1, columns: [t1.v1, t1.v2] }
    └─LogicalScan { table: t3, output_columns: [t3.v1, t3.v2], required_columns: [v1, v2], predicate: (t3.v1 > 1:Int32) }
  batch_local_plan: |
    BatchLookupJoin { type: Inner, predicate: t1.v2 = t3.v1 AND (t3.v1 > 1:Int32), output: all }
    └─BatchExchange { order: [], dist: Single }
      └─BatchScan { table: t1, columns: [t1.v1, t1.v2], distribution: SomeShard }
  with_config_map:
    QUERY_MODE: local
    RW_BATCH_ENABLE_LOOKUP_JOIN: 'true'
- name: Use project to do the calculation
  sql: |
    create table t1(x int, y int);
    create table t2(x int, y int);
    select * from t1, t2 where t1.x + t1.y = t2.x + t2.y;
  optimized_logical_plan: |
    LogicalJoin { type: Inner, on: ((t1.x + t1.y) = (t2.x + t2.y)), output: [t1.x, t1.y, t2.x, t2.y] }
    ├─LogicalProject { exprs: [t1.x, t1.y, (t1.x + t1.y)] }
    | └─LogicalScan { table: t1, columns: [t1.x, t1.y] }
    └─LogicalProject { exprs: [t2.x, t2.y, (t2.x + t2.y)] }
      └─LogicalScan { table: t2, columns: [t2.x, t2.y] }
- name: Use project to align return types
  sql: |
    create table t1(x int, y int);
    create table t2(x int, y decimal);
    select * from t1, t2 where t1.x = t2.y;
  optimized_logical_plan: |
    LogicalJoin { type: Inner, on: (t1.x::Decimal = t2.y), output: [t1.x, t1.y, t2.x, t2.y] }
    ├─LogicalProject { exprs: [t1.x, t1.y, t1.x::Decimal] }
    | └─LogicalScan { table: t1, columns: [t1.x, t1.y] }
    └─LogicalProject { exprs: [t2.x, t2.y, t2.y] }
      └─LogicalScan { table: t2, columns: [t2.x, t2.y] }
