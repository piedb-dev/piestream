# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- sql: |
    create table t(x int);
    select sum(x) over() from t;
  binder_error: |-
    Feature is not yet implemented: aggregate function as over window function: sum
    Tracking issue: https://github.com/piestreamlabs/piestream/issues/4978
- sql: |
    create table t(x int);
    select row_number(x) over() from t;
  binder_error: 'Bind error: the length of args of ROW_NUMBER function should be 0'
- sql: |
    create table t(x int);
    select row_number() over() from t;
  planner_error: 'Invalid input syntax: window rank function without order by: ROW_NUMBER()
    OVER()'
- sql: |
    create table t(x int);
    select row_number() over(PARTITION BY x ORDER BY x) from t;
  logical_plan: |
    LogicalProject { exprs: [ROW_NUMBER] }
    └─LogicalOverAgg { window_function: ROW_NUMBER() OVER(PARTITION BY t.x ORDER BY t.x ASC NULLS LAST) }
      └─LogicalScan { table: t, columns: [t.x, t._row_id] }
- sql: |
    create table t(x int);
    select row_number() over(PARTITION BY x ORDER BY x ROWS BETWEEN 10 PRECEDING AND CURRENT ROW) from t;
  binder_error: |-
    Feature is not yet implemented: window frame: ROWS BETWEEN 10 PRECEDING AND CURRENT ROW
    No tracking issue yet. Feel free to submit a feature request at https://github.com/piestreamlabs/piestream/issues/new?labels=type%2Ffeature&template=feature_request.yml
- sql: |
    create table t(x int);
    select row_number() over(ORDER BY x), row_number() over(ORDER BY x) from t;
  planner_error: |-
    Feature is not yet implemented: Multiple window functions
    No tracking issue yet. Feel free to submit a feature request at https://github.com/piestreamlabs/piestream/issues/new?labels=type%2Ffeature&template=feature_request.yml
- sql: |
    create table t(x int);
    select 1+row_number() over(ORDER BY x) from t;
  planner_error: |-
    Feature is not yet implemented: window function in expression: (1:Int32 + ROW_NUMBER() OVER(ORDER BY $0))
    No tracking issue yet. Feel free to submit a feature request at https://github.com/piestreamlabs/piestream/issues/new?labels=type%2Ffeature&template=feature_request.yml
- sql: |
    create table t(x int);
    select * from t order by (row_number() over(PARTITION BY x ORDER BY x));
  logical_plan: |
    LogicalProject { exprs: [t.x] }
    └─LogicalProject { exprs: [t.x, ROW_NUMBER] }
      └─LogicalOverAgg { window_function: ROW_NUMBER() OVER(PARTITION BY t.x ORDER BY t.x ASC NULLS LAST) }
        └─LogicalScan { table: t, columns: [t.x, t._row_id] }
- sql: |
    create table t(x int);
    select x from t group by (row_number(x) over());
  binder_error: 'Invalid input syntax: window functions are not allowed in GROUP BY'
- sql: |
    create table t(x int);
    select x from t having (row_number(x) over() > 1);
  binder_error: 'Invalid input syntax: window functions are not allowed in HAVING'
- sql: |
    create table t(x int);
    select x from t where (row_number(x) over() > 1);
  binder_error: 'Invalid input syntax: window functions are not allowed in WHERE'
- sql: |
    create table t(x int);
    select sum(x) filter (where row_number() over () > 1) from t;
  binder_error: 'Invalid input syntax: window functions are not allowed in FILTER'
- name: TopN with rank output
  sql: |
    create table t(x int);
    select * from
      (select *, row_number() over(PARTITION BY x ORDER BY x) rank from t)
    where rank<3;
  logical_plan: |
    LogicalProject { exprs: [t.x, ROW_NUMBER] }
    └─LogicalFilter { predicate: (ROW_NUMBER < 3:Int32) }
      └─LogicalProject { exprs: [t.x, ROW_NUMBER] }
        └─LogicalOverAgg { window_function: ROW_NUMBER() OVER(PARTITION BY t.x ORDER BY t.x ASC NULLS LAST) }
          └─LogicalScan { table: t, columns: [t.x, t._row_id] }
  optimizer_error: |
    internal error: OverAgg can not be transformed. Plan:
    LogicalProject { exprs: [t.x, ROW_NUMBER] }
    └─LogicalFilter { predicate: (ROW_NUMBER < 3:Int32) }
      └─LogicalOverAgg { window_function: ROW_NUMBER() OVER(PARTITION BY t.x ORDER BY t.x ASC NULLS LAST) }
        └─LogicalScan { table: t, columns: [t.x, t._row_id] }
- name: TopN without rank output
  sql: |
    create table t(x int, y int);
    select x, y from
      (select *, row_number() over(PARTITION BY y ORDER BY x) rank from t)
    where rank<3 AND x>y;
  logical_plan: |
    LogicalProject { exprs: [t.x, t.y] }
    └─LogicalFilter { predicate: (ROW_NUMBER < 3:Int32) AND (t.x > t.y) }
      └─LogicalProject { exprs: [t.x, t.y, ROW_NUMBER] }
        └─LogicalOverAgg { window_function: ROW_NUMBER() OVER(PARTITION BY t.y ORDER BY t.x ASC NULLS LAST) }
          └─LogicalScan { table: t, columns: [t.x, t.y, t._row_id] }
  optimized_logical_plan: |
    LogicalProject { exprs: [t.x, t.y] }
    └─LogicalTopN { order: "[t.x ASC]", limit: 2, offset: 0, group_key: [1] }
      └─LogicalScan { table: t, output_columns: [t.x, t.y, t._row_id], required_columns: [x, y, _row_id], predicate: (t.x > t.y) }
  batch_plan: |
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [t.x, t.y] }
      └─BatchGroupTopN { order: "[t.x ASC]", limit: 2, offset: 0, group_key: [1] }
        └─BatchExchange { order: [], dist: HashShard(t.y) }
          └─BatchFilter { predicate: (t.x > t.y) }
            └─BatchScan { table: t, columns: [t.x, t.y, t._row_id], distribution: UpstreamHashShard(t._row_id) }
  stream_plan: |
    StreamMaterialize { columns: [x, y, t._row_id(hidden)], pk_columns: [t._row_id] }
    └─StreamExchange { dist: HashShard(t._row_id) }
      └─StreamProject { exprs: [t.x, t.y, t._row_id] }
        └─StreamGroupTopN { order: "[t.x ASC]", limit: 2, offset: 0, group_key: [1] }
          └─StreamExchange { dist: HashShard(t.y) }
            └─StreamFilter { predicate: (t.x > t.y) }
              └─StreamTableScan { table: t, columns: [t.x, t.y, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
- sql: |
    create table t(x int, y int);
    select x, y from
      (select *, row_number() over(PARTITION BY y ORDER BY x) rank from t)
    where rank<=3;
  optimized_logical_plan: |
    LogicalProject { exprs: [t.x, t.y] }
    └─LogicalTopN { order: "[t.x ASC]", limit: 3, offset: 0, group_key: [1] }
      └─LogicalScan { table: t, columns: [t.x, t.y, t._row_id] }
- sql: |
    create table t(x int, y int);
    select x, y from
      (select *, rank() over(PARTITION BY y ORDER BY x) rank from t)
    where rank<=3;
  stream_plan: |
    StreamMaterialize { columns: [x, y, t._row_id(hidden)], pk_columns: [t._row_id] }
    └─StreamExchange { dist: HashShard(t._row_id) }
      └─StreamProject { exprs: [t.x, t.y, t._row_id] }
        └─StreamGroupTopN { order: "[t.x ASC]", limit: 3, offset: 0, group_key: [1], with_ties: true }
          └─StreamExchange { dist: HashShard(t.y) }
            └─StreamTableScan { table: t, columns: [t.x, t.y, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
- sql: |
    create table t(x int, y int);
    select x, y from
      (select *, row_number() over(PARTITION BY y ORDER BY x) rank from t)
    where rank>3;
  optimized_logical_plan: |
    LogicalProject { exprs: [t.x, t.y] }
    └─LogicalTopN { order: "[t.x ASC]", limit: 9223372036854775807, offset: 3, group_key: [1] }
      └─LogicalScan { table: t, columns: [t.x, t.y, t._row_id] }
  stream_error: 'Invalid input syntax: OFFSET without LIMIT in streaming mode'
- sql: |
    create table t(x int, y int);
    select x, y from
      (select *, row_number() over(PARTITION BY y ORDER BY x) rank from t)
    where rank>=3;
  optimized_logical_plan: |
    LogicalProject { exprs: [t.x, t.y] }
    └─LogicalTopN { order: "[t.x ASC]", limit: 9223372036854775807, offset: 2, group_key: [1] }
      └─LogicalScan { table: t, columns: [t.x, t.y, t._row_id] }
- sql: |
    create table t(x int, y int);
    select x, y from
      (select *, row_number() over(PARTITION BY y ORDER BY x) rank from t)
    where 3 <= rank AND rank <= 5;
    -- complex rank range is not supported yet
  optimizer_error: |
    internal error: OverAgg can not be transformed. Plan:
    LogicalProject { exprs: [t.x, t.y] }
    └─LogicalFilter { predicate: (3:Int32 <= ROW_NUMBER) AND (ROW_NUMBER <= 5:Int32) }
      └─LogicalOverAgg { window_function: ROW_NUMBER() OVER(PARTITION BY t.y ORDER BY t.x ASC NULLS LAST) }
        └─LogicalScan { table: t, columns: [t.x, t.y, t._row_id] }
- id: create_bid
  sql: |
    /*
    The following example is adapted from
    https://nightlies.apache.org/flink/flink-docs-release-1.16/docs/dev/table/sql/queries/window-topn/

    Licensed to the Apache Software Foundation (ASF) under one
    or more contributor license agreements.  See the NOTICE file
    distributed with this work for additional information
    regarding copyright ownership.  The ASF licenses this file
    to you under the Apache License, Version 2.0 (the
    "License"); you may not use this file except in compliance
    with the License.  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing,
    software distributed under the License is distributed on an
    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, either express or implied.  See the License for the
    specific language governing permissions and limitations
    under the License.
    */
    CREATE TABLE bid (
      "bidtime" TIMESTAMP,
      "price" BIGINT,
      "item" VARCHAR,
      "supplier_id" VARCHAR
    );
- before:
  - create_bid
  sql: |
    -- Window Top-N which follows after Window Aggregation
    -- Top 3 suppliers who have the highest sales for every tumbling 10 minutes window.
    SELECT window_start, window_end, supplier_id, price, cnt
    FROM (
      SELECT *, ROW_NUMBER() OVER (PARTITION BY window_start, window_end ORDER BY price DESC) as rownum
      FROM (
        SELECT window_start, window_end, supplier_id, SUM(price) as price, COUNT(*) as cnt
        FROM
          TUMBLE(Bid, bidtime, INTERVAL '10' MINUTE)
        GROUP BY window_start, window_end, supplier_id
      )
    ) WHERE rownum <= 3;
  stream_plan: |
    StreamMaterialize { columns: [window_start, window_end, supplier_id, price, cnt], pk_columns: [window_start, window_end, supplier_id] }
    └─StreamGroupTopN { order: "[sum(bid.price) DESC]", limit: 3, offset: 0, group_key: [0, 1] }
      └─StreamExchange { dist: HashShard(TumbleStart(bid.bidtime, '00:10:00':Interval), (TumbleStart(bid.bidtime, '00:10:00':Interval) + '00:10:00':Interval)) }
        └─StreamProject { exprs: [TumbleStart(bid.bidtime, '00:10:00':Interval), (TumbleStart(bid.bidtime, '00:10:00':Interval) + '00:10:00':Interval), bid.supplier_id, sum(bid.price), count] }
          └─StreamHashAgg { group_key: [TumbleStart(bid.bidtime, '00:10:00':Interval), (TumbleStart(bid.bidtime, '00:10:00':Interval) + '00:10:00':Interval), bid.supplier_id], aggs: [count, sum(bid.price), count] }
            └─StreamExchange { dist: HashShard(TumbleStart(bid.bidtime, '00:10:00':Interval), (TumbleStart(bid.bidtime, '00:10:00':Interval) + '00:10:00':Interval), bid.supplier_id) }
              └─StreamProject { exprs: [TumbleStart(bid.bidtime, '00:10:00':Interval), (TumbleStart(bid.bidtime, '00:10:00':Interval) + '00:10:00':Interval), bid.supplier_id, bid.price, bid._row_id] }
                └─StreamTableScan { table: bid, columns: [bid.bidtime, bid.price, bid.item, bid.supplier_id, bid._row_id], pk: [bid._row_id], dist: UpstreamHashShard(bid._row_id) }
- before:
  - create_bid
  sql: |
    -- Window Top-N follows directly after Window TVF
    -- Top 3 items which have the highest price for every tumbling 10 minutes window.
    SELECT window_start, window_end, supplier_id, price
    FROM (
      SELECT *, ROW_NUMBER() OVER (PARTITION BY window_start, window_end ORDER BY price DESC) as rownum
        FROM
          TUMBLE(Bid, bidtime, INTERVAL '10' MINUTE)
    ) WHERE rownum <= 3;
  stream_plan: |
    StreamMaterialize { columns: [window_start, window_end, supplier_id, price, bid._row_id(hidden)], pk_columns: [bid._row_id] }
    └─StreamExchange { dist: HashShard(bid._row_id) }
      └─StreamProject { exprs: [TumbleStart(bid.bidtime, '00:10:00':Interval), (TumbleStart(bid.bidtime, '00:10:00':Interval) + '00:10:00':Interval), bid.supplier_id, bid.price, bid._row_id] }
        └─StreamGroupTopN { order: "[bid.price DESC]", limit: 3, offset: 0, group_key: [5, 6] }
          └─StreamExchange { dist: HashShard(TumbleStart(bid.bidtime, '00:10:00':Interval), (TumbleStart(bid.bidtime, '00:10:00':Interval) + '00:10:00':Interval)) }
            └─StreamProject { exprs: [bid.bidtime, bid.price, bid.item, bid.supplier_id, bid._row_id, TumbleStart(bid.bidtime, '00:10:00':Interval), (TumbleStart(bid.bidtime, '00:10:00':Interval) + '00:10:00':Interval)] }
              └─StreamTableScan { table: bid, columns: [bid.bidtime, bid.price, bid.item, bid.supplier_id, bid._row_id], pk: [bid._row_id], dist: UpstreamHashShard(bid._row_id) }
- name: Deduplication
  sql: |
    create table t(x int, y int);
    select x, y from
      (select *, row_number() over(PARTITION BY x ORDER BY y) rank from t)
    where rank = 1
  logical_plan: |
    LogicalProject { exprs: [t.x, t.y] }
    └─LogicalFilter { predicate: (ROW_NUMBER = 1:Int32) }
      └─LogicalProject { exprs: [t.x, t.y, ROW_NUMBER] }
        └─LogicalOverAgg { window_function: ROW_NUMBER() OVER(PARTITION BY t.x ORDER BY t.y ASC NULLS LAST) }
          └─LogicalScan { table: t, columns: [t.x, t.y, t._row_id] }
  optimized_logical_plan: |
    LogicalProject { exprs: [t.x, t.y] }
    └─LogicalTopN { order: "[t.y ASC]", limit: 1, offset: 0, group_key: [0] }
      └─LogicalScan { table: t, columns: [t.x, t.y, t._row_id] }
  stream_plan: |
    StreamMaterialize { columns: [x, y, t._row_id(hidden)], pk_columns: [t._row_id] }
    └─StreamExchange { dist: HashShard(t._row_id) }
      └─StreamProject { exprs: [t.x, t.y, t._row_id] }
        └─StreamGroupTopN { order: "[t.y ASC]", limit: 1, offset: 0, group_key: [0] }
          └─StreamExchange { dist: HashShard(t.x) }
            └─StreamTableScan { table: t, columns: [t.x, t.y, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
